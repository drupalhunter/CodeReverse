////////////////////////////////////////////////////////////////////////////
// asmpat32.dat
// Copyright (C) 2013-2014 Katayama Hirofumi MZ.  All rights reserved.
////////////////////////////////////////////////////////////////////////////
// This file is part of CodeReverse.
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// updated

pattern {
    updated al;
} code {
    xsigned long long $n;
    ax := (ah << 8) | al;
    eax := (eax & 0xFFFF0000) | ax;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated bl;
} code {
    bx := (bh << 8 | bl);
    ebx := (ebx & 0xFFFF0000) | bx;
}

pattern {
    updated cl;
} code {
    cx := (ch << 8 | cl);
    ecx := (ecx & 0xFFFF0000) | cx;
}

pattern {
    updated dl;
} code {
    xsigned long long $n;
    dx := (dh << 8) | dl;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated ah;
} code {
    xsigned long long $n;
    ax := (ah << 8) | al;
    eax := (eax & 0xFFFF0000) | al;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated bh;
} code {
    bx := (bh << 8) | bl;
    ebx := (ebx & 0xFFFF0000) | bx;
}

pattern {
    updated ch;
} code {
    cx := (ch << 8) | cl;
    ecx := (ecx & 0xFFFF0000) | cx;
}

pattern {
    updated dh;
} code {
    xsigned long long $n;
    dx := (dh << 8) | dl;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated ax;
} code {
    xsigned long long $n;
    al := ax & 0xFF;
    ah := (ax >> 8) & 0xFF;
    eax := (eax & 0xFFFF0000) | ax;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated bx;
} code {
    bl := bx & 0xFF;
    bh := (bx >> 8) & 0xFF;
    ebx := (ebx & 0xFFFF0000) | bx;
}

pattern {
    updated cx;
} code {
    cl := cx & 0xFF;
    ch := (cx >> 8) & 0xFF;
    ecx := (ecx & 0xFFFF0000) | cx;
}

pattern {
    updated dx;
} code {
    xsigned long long $n;
    dl := dx & 0xFF;
    dh := (dx >> 8) & 0xFF;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated sp;
} code {
    esp := (esp & 0xFFFF0000) | sp;
}

pattern {
    updated bp;
} code {
    ebp := (ebp & 0xFFFF0000) | bp;
}

pattern {
    updated si;
} code {
    esi := (esi & 0xFFFF0000) | si;
}

pattern {
    updated di;
} code {
    edi := (edi & 0xFFFF0000) | di;
}

pattern {
    updated eax;
} code {
    xsigned long long $n;
    al := eax & 0xFF;
    ah := (eax >>> 8) & 0xFF;
    ax := eax & 0xFFFF;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated ebx;
} code {
    bl := ebx & 0xFF;
    bh := (ebx >>> 8) & 0xFF;
    bx := ebx & 0xFFFF;
}

pattern {
    updated ecx;
} code {
    cl := ecx & 0xFF;
    ch := (ecx >>> 8) & 0xFF;
    cx := ecx & 0xFFFF;
}

pattern {
    updated edx;
} code {
    xsigned long long $n;
    dl := edx & 0xFF;
    dh := (edx >>> 8) & 0xFF;
    dx := edx & 0xFFFF;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated esp;
} code {
    sp := esp & 0xFFFF;
}

pattern {
    updated ebp;
} code {
    bp := ebp & 0xFFFF;
}

pattern {
    updated esi;
} code {
    si := esi & 0xFFFF;
}

pattern {
    updated edi;
} code {
    di := edi & 0xFFFF;
}

pattern {
    updated al, ah;
} code {
    xsigned long long $n;
    ax := (ah << 8) | al;
    eax := (eax & 0xFFFF0000) | ax;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated bl, bh;
} code {
    bx := (bh << 8) | bl;
    ebx := (ebx & 0xFFFF0000) | bx;
}

pattern {
    updated cl, ch;
} code {
    cx := (ch << 8) | cl;
    ecx := (ecx & 0xFFFF0000) | cx;
}

pattern {
    updated dl, dh;
} code {
    xsigned long long $n;
    dx := (dh << 8) | dl;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated ax, dx;
} code {
    xsigned long long $n;
    al := ax & 0xFF;
    ah := (ax >> 8) & 0xFF;
    eax := (eax & 0xFFFF0000) | ax;
    dl := dx & 0xFF;
    dh := (dx >> 8) & 0xFF;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (dx << 16) | ax;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated dx:ax;
} code {
    xsigned long long $n;
    al := dx:ax & 0xFF;
    ah := (dx:ax >> 8) & 0xFF;
    ax := dx:ax & 0xFFFF;
    eax := (eax & 0xFFFF0000) | ax;
    dl := (dx:ax >> 16) & 0xFF;
    dh := (dx:ax >> 24) & 0xFF;
    dx := (dx:ax >> 16) & 0xFFFF;
    edx := (edx & 0xFFFF0000) | dx;
    $n := edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated eax, edx;
} code {
    xsigned long long $n;
    al := eax & 0xFF;
    ah := (eax >> 8) & 0xFF;
    ax := eax & 0xFFFF;
    dl := dx & 0xFF;
    dh := (dx >> 8) & 0xFF;
    dx := edx & 0xFFFF;
    dx:ax := (dx << 16) | ax;
    $n = edx;
    edx:eax := ($n << 32) | eax;
}

pattern {
    updated edx:eax;
} code {
    al := edx:eax & 0xFF;
    ah := (edx:eax >> 8) & 0xFF;
    ax := edx:eax & 0xFFFF;
    eax := edx:eax & 0xFFFFFFFF;
    dl := (edx:eax >> 32) & 0xFF;
    dh := (edx:eax >> 40) & 0xFF;
    dx := (edx:eax >> 32) & 0xFFFF;
    edx := (edx:eax >> 32) & 0xFFFFFFFF;
    dx:ax := (dx << 16) | ax;
}

pattern {
    updated $1;
    assume $1 as memory;
} code {
}

////////////////////////////////////////////////////////////////////////////
// technical

pattern {
    push $1;
    pop $1;
} code {
}

pattern {
    push $1;
    push $2;
    pop $2;
    pop $1;
} code {
}

pattern {
    push $1;
    push $2;
    push $3;
    pop $3;
    pop $2;
    pop $1;
} code {
}

pattern {
    push $1;
    push $2;
    push $3;
    push $4;
    pop $4;
    pop $3;
    pop $2;
    pop $1;
} code {
}

pattern {
    push $1;
    pop $2;
} code {
    $2 := $1;
    updated $2;
}

pattern {
    push $1;
    push $2;
    pop $3;
    pop $4;
} code {
    $3 := $2;
    $4 := $1;
    updated $3;
    updated $4;
}

pattern {
    push $1;
    push $2;
    push $3;
    pop $4;
    pop $5;
    pop $6;
} code {
    $4 := $3;
    $5 := $2;
    $6 := $1;
    updated $4;
    updated $5;
    updated $6;
}

pattern {
    push $1;
    push $2;
    push $3;
    push $4;
    pop $5;
    pop $6;
    pop $7;
    pop $8;
} code {
    $5 := $4;
    $6 := $3;
    $7 := $2;
    $8 := $1;
    updated $5;
    updated $6;
    updated $7;
    updated $8;
}

pattern {
    push $1;
    push $2;
    push $3;
    push $4;
    push $5;
    pop $6;
    pop $7;
    pop $8;
    pop $9;
    pop $10;
} code {
    $6 := $5;
    $7 := $4;
    $8 := $3;
    $9 := $2;
    $10 := $1;
    updated $6;
    updated $5;
    updated $6;
    updated $7;
    updated $8;
}

pattern {
    assume eax == 0;
    assume ecx == 0xFFFFFFFF;
    repne scasb;
    not ecx;
    lea $1, [ecx-1];
} code {
    assume edi as char *;
    assume $1 as size_t;
    $1 := strlen(edi);
    edi := edi + $1;
    updated $1;
    updated edi;
    assume ecx == 0;
}

pattern {
    cdq;
    xor eax, edx;
    sub eax, edx;
} code {
    eax := abs(eax);
    dead dl;
    dead dh;
    dead dx;
    dead edx;
    updated eax;
}

pattern {
    push ebp;
    mov ebp, esp;
    sub esp, $1;
} code {
    enter $1, 0;
}

pattern {
    push ebp;
    mov ebp, esp;
} code {
    enter 0, 0;
}

pattern {
    mov esp, ebp;
    pop ebp;
} code {
    leave;
}

pattern {
    xor $1, $1;
    not $1;
    assume sizeof($1) == 4;
} code {
    $1 := 0xFFFFFFFF;
    updated $1;
}

pattern {
    xor $1, $1;
    not $1;
    assume sizeof($1) == 2;
} code {
    $1 := 0xFFFF;
    updated $1;
    assume $1 as xsigned short;
}

pattern {
    xor $1, $1;
    not $1;
    assume sizeof($1) == 1;
} code {
    $1 := 0xFF;
    updated $1;
    assume $1 as xsigned char;
}

pattern {
    xor $1, $1;
    inc $1;
    assume sizeof($1) == 4;
} code {
    $1 := 1;
    updated $1;
    assume $1 as xsigned long;
}

pattern {
    xor $1, $1;
    inc $1;
    assume sizeof($1) == 2;
} code {
    $1 := 1;
    updated $1;
    assume $1 as xsigned short;
}

pattern {
    xor $1, $1;
    inc $1;
    assume sizeof($1) == 1;
} code {
    $1 := 1;
    updated $1;
    assume $1 as xsigned char;
}

pattern {
    xor $1, $1;
    dec $1;
    assume sizeof($1) == 4;
} code {
    $1 := 0xFFFFFFFF;
    updated $1;
    dead OF;
    SF := 1;
    ZF := 0;
    dead AF;
    dead PF;
}

pattern {
    xor $1, $1;
    dec $1;
    assume sizeof($1) == 2;
} code {
    $1 := 0xFFFF;
    updated $1;
    assume $1 as xsigned short;
    dead OF;
    SF := 1;
    ZF := 0;
    dead AF;
    dead PF;
}

pattern {
    xor $1, $1;
    dec $1;
    assume sizeof($1) == 1;
} code {
    $1 := 0xFF;
    updated $1;
    assume $1 as xsigned char;
    dead OF;
    SF := 1;
    ZF := 0;
    dead AF;
    dead PF;
}

pattern {
    xor $1, $1;
} code {
    $1 := 0;
    updated $1;
    SF := 0;
    ZF := 1;
    OF := 0;
    CF := 0;
    dead PF;
    dead AF;
}

pattern {
    and $1, $1;
    assume sizeof($1) == 4;
} code {
    long $n;
    $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    dead AF;
    dead PF;
}

pattern {
    and $1, $1;
    assume sizeof($1) == 2;
} code {
    short $n;
    $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    dead AF;
    dead PF;
}

pattern {
    and $1, $1;
    assume sizeof($1) == 1;
} code {
    char $n;
    $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    dead AF;
    dead PF;
}

pattern {
    mov $1, $1;
} code {
}

pattern {
    movnti $1, $1;
} code {
}

pattern {
    or $1, $1;
} code {
    SF := 0;
    dead PF;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    dead AF;
}

pattern {
    test $1, $1;
    assume sizeof($1) == 4;
} code {
    long $temp;
    ZF := $1 == 0;
    $temp := $1;
    SF := $temp < 0;
    dead PF;
    CF := 0;
    OF := 0;
    dead AF;
}

pattern {
    test $1, $1;
    assume sizeof($1) == 2;
} code {
    short $temp;
    ZF := $1 == 0;
    $temp := $1;
    SF := $temp < 0;
    dead PF;
    CF := 0;
    OF := 0;
    dead AF;
}

pattern {
    test $1, $1;
    assume sizeof($1) == 1;
} code {
    char $temp;
    ZF := $1 == 0;
    $temp := $1;
    SF := $temp < 0;
    dead PF;
    CF := 0;
    OF := 0;
    dead AF;
}

pattern {
    shr $1, 1;
    shr $1, 1;
    shr $1, 1;
    shr $1, 1;
    shr $1, 1;
} code {
    shr $1, 5;
}

pattern {
    shr $1, 1;
    shr $1, 1;
    shr $1, 1;
    shr $1, 1;
} code {
    shr $1, 4;
}

pattern {
    shr $1, 1;
    shr $1, 1;
    shr $1, 1;
} code {
    shr $1, 3;
}

pattern {
    shr $1, 1;
    shr $1, 1;
} code {
    shr $1, 2;
}

pattern {
    bsr $1, $2;
    cmovz $3, $1;
    assume sizeof($1) == 4;
} code {
    long $temp;
    ZF := 0;
    $temp := 31;
$loop:
    if (($2 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp - 1;
    goto $loop;
$skip:
    $3 := $temp;
    updated $3;
    dead $1;
    dead CF;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    bsr $1, $2;
    cmovz $3, $1;
    assume sizeof($1) == 2;
} code {
    short $temp;
    ZF := 0;
    $temp := 15;
$loop:
    if (($2 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp - 1;
    goto $loop;
$skip:
    $3 := $temp;
    updated $3;
    dead $1;
    dead CF;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

////////////////////////////////////////////////////////////////////////////
// instructions

pattern {
    aaa;
} code {
    if ((al & 0x0F) >= 10 || AF) goto $skip;
    AF := 0;
    CF := 0;
    goto $join;
$skip:
    al := al + 6;
    ah := ah + 1;
    AF := 1;
    CF := 1;
$join:
    al := al & 0x0F;
    updated al, ah;
    dead OF;
    dead SF;
    dead ZF;
    dead PF;
}

pattern {
    aad;
} code {
    char $s;
    al := al + ah * 10;
    ZF := al == 0;
    $s := al;
    SF := $s < 0;
    ah := 0;
    updated al, ah;
    dead OF;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    aam, $1;
} code {
    char $s;
    ah := al / $1;
    al := al % $1;
    ZF := al == 0;
    $s := al;
    SF := $s < 0;
    updated al, ah;
    dead OF;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    aas;
} code {
    if ((al & 0F) >= 10 || AF) goto $skip;
    AF := 0;
    CF := 0;
    goto $join;
$skip:
    al := al - 6;
    ah := ah - 1;
    AF := 1;
    CF := 1;
$join:
    al := al & 0x0F;
    updated al, ah;
    dead OF;
    dead SF;
    dead ZF;
    dead PF;
}

pattern {
    adc $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n1;
    long $n2;
    long $n3;
    unsigned long $m1;
    unsigned long $m2;
    unsigned long $m3;
    $n1 := $1;
    $n2 := $2 + CF;
    $m1 := $1
    $m2 := $2 + CF;
    $1 := $1 + $2 + CF;
    updated $1;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $1 == 0;
    SF := $n3 < 0;
    CF := ($m1 > $m3 - CF) || ($m1 > $m3);
    dead AF;
    dead PF;
}

pattern {
    adc $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n1;
    short $n2;
    short $n3;
    unsigned short $m1;
    unsigned short $m2;
    unsigned short $m3;
    $n1 := $1;
    $n2 := $2 + CF;
    $m1 := $1
    $m2 := $2 + CF;
    $1 := $1 + $2 + CF;
    updated $1;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $1 == 0;
    SF := $n3 < 0;
    CF := ($m1 > $m3 - CF) || ($m1 > $m3);
    dead AF;
    dead PF;
}

pattern {
    adc $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n1;
    char $n2;
    char $n3;
    unsigned char $m1;
    unsigned char $m2;
    unsigned char $m3;
    $n1 := $1;
    $n2 := $2 + CF;
    $m1 := $1
    $m2 := $2 + CF;
    $1 := $1 + $2 + CF;
    updated $1;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $1 == 0;
    SF := $n3 < 0;
    CF := ($m1 > $m3 - CF) || ($m1 > $m3);
    dead AF;
    dead PF;
}

pattern {
    add $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n1;
    long $n2;
    long $n3;
    unsigned long $m1;
    unsigned long $m2;
    unsigned long $m3;
    $n1 := $1;
    $n2 := $2;
    $m1 := $1;
    $m2 := $2;
    $1 := $1 + $2;
    updated $1;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $1 == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    dead AF;
    dead PF;
}

pattern {
    add $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n1;
    short $n2;
    short $n3;
    unsigned short $m1;
    unsigned short $m2;
    unsigned short $m3;
    $n1 := $1;
    $n2 := $2;
    $m1 := $1;
    $m2 := $2;
    $1 := $1 + $2;
    updated $1;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $1 == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    dead AF;
    dead PF;
}

pattern {
    add $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n1;
    char $n2;
    char $n3;
    unsigned char $m1;
    unsigned char $m2;
    unsigned char $m3;
    $n1 := $1;
    $n2 := $2;
    $m1 := $1;
    $m2 := $2;
    $1 := $1 + $2;
    updated $1;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $1 == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    dead AF;
    dead PF;
}

pattern {
    and $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n;
    $1 := $1 & $2;
    updated $1;
    $n := $1;
    ZF := $1 == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    dead AF;
    dead PF;
}

pattern {
    and $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n;
    $1 := $1 & $2;
    updated $1;
    $n := $1;
    ZF := $1 == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    dead AF;
    dead PF;
}

pattern {
    and $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n;
    $1 := $1 & $2;
    updated $1;
    $n := $1;
    ZF := $1 == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    dead AF;
    dead PF;
}

// arpl($dest, $src);
// bound($dest, $src);

pattern {
    bsf $1, $2;
    assume sizeof($1) == 4;
} code {
    long $temp;
    if ($2 == 0) goto $error;
    ZF := 0;
    $temp := 0;
$loop:
    if (($1 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp + 1;
    goto $loop;
$skip:
    $1 := $temp;
    updated $1;
    goto $end;
$error:
    ZF := 1;
    dead $1;
$end:
    dead CF;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    bsf $1, $2;
    assume sizeof($1) == 2;
} code {
    short $temp;
    if ($2 == 0) goto $error;
    ZF := 0;
    $temp := 0;
$loop:
    if (($1 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp + 1;
    goto $loop;
$skip:
    $1 := $temp;
    updated $1;
    goto $end;
$error:
    ZF := 1;
    dead $1;
$end:
    dead CF;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    bsr $1, $2;
    assume sizeof($1) == 4;
} code {
    long $temp;
    if ($2 == 0) goto $error;
    ZF := 0;
    $temp := 31;
$loop:
    if (($2 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp - 1;
    goto $loop;
$skip:
    $1 := $temp;
    updated $1;
    goto $end;
$error:
    ZF := 1;
    dead $1;
$end:
    dead CF;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    bsr $1, $2;
    assume sizeof($1) == 2;
} code {
    short $temp;
    if ($2 == 0) goto $error;
    ZF := 0;
    $temp := 15;
$loop:
    if (($2 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp - 1;
    goto $loop;
$skip:
    $1 := $temp;
    updated $1;
    goto $end;
$error:
    ZF := 1;
    dead $1;
$end:
    dead CF;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    bswap $1;
    assume sizeof($1) == 4;
} code {
    $1 := _bswap($1);
    updated $1;
}

pattern {
    bt $1, $2;
} code {
    CF := ($1 & (1 << $2)) != 0;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    btc $1, $2;
} code {
    CF := ($1 & (1 << $2)) != 0;
    if (CF) goto $reset;
    $1 := $1 | (1 << $2);
    goto $join;
$reset:
    $1 := $1 & ~(1 << $2);
$join:
    updated $1;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    btr $1, $2;
} code {
    CF := ($1 & (1 << $2)) != 0;
    $1 := $1 & ~(1 << $2);
    updated $1;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    bts $1, $2;
} code {
    CF := ($1 & (1 << $2)) != 0;
    $1 := $1 | (1 << $2);
    updated $1;
    dead OF;
    dead SF;
    dead AF;
    dead PF;
}

pattern {
    cbw;
} code {
    assume al as char;
    ax := al;
    updated ax;
    assume ax as short;
}

pattern {
    cwde;
} code {
    assume ax as short;
    eax := ax;
    updated eax;
    assume eax as int;
}

pattern {
    clc
} code {
    CF := 0;
}

pattern {
    cld;
} code {
    DF := 0;
}

// clflush($m8);

pattern {
    cli;
} code {
    IF := 0;
}

// clts();

pattern {
    cmc;
} code {
    CF := !CF;
}

pattern {
    cmova $1, $2;
} code {
    if (CF || ZF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovae $1, $2;
} code {
    if (CF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovb $1, $2;
} code {
    if (!CF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovbe $1, $2;
} code {
    if (!CF && !ZF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovc $1, $2;
} code {
    if (!CF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmove $1, $2;
} code {
    if (!ZF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovg $1, $2;
} code {
    if (ZF || SF != OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovge $1, $2;
} code {
    if (SF != OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovl $1, $2;
} code {
    if (SF == OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovle $1, $2;
} code {
    if (!ZF && SF == OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovna $1, $2;
} code {
    if (!CF && !ZF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnae $1, $2;
} code {
    if (!CF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnb $1, $2;
} code {
    if (CF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnbe $1, $2;
} code {
    if (CF || ZF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnc $1, $2;
} code {
    if (CF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovne $1, $2;
} code {
    if (ZF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovng $1, $2;
} code {
    if (!ZF && SF == OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnge $1, $2;
} code {
    if (SF == OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnl $1, $2;
} code {
    if (SF != OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnle $1, $2;
} code {
    if (ZF || SF != OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovno $1, $2;
} code {
    if (OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnp $1, $2;
} code {
    if (PF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovns $1, $2;
} code {
    if (SF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovnz $1, $2;
} code {
    if (ZF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovo $1, $2;
} code {
    if (!OF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovp $1, $2;
} code {
    if (!PF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovpe $1, $2;
} code {
    if (!PF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovpo $1, $2;
} code {
    if (PF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovs $1, $2;
} code {
    if (!SF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmovz $1, $2;
} code {
    if (!ZF) goto $skip;
    $1 := $2;
    updated $1;
$skip:
}

pattern {
    cmp $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    ZF := $1 == $2;
    SF := $n1 < $n2;
    dead OF;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
}

pattern {
    cmp $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    ZF := $1 == $2;
    SF := $n1 < $n2;
    dead OF;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
}

pattern {
    cmp $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    ZF := $1 == $2;
    SF := $n1 < $n2;
    dead OF;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
}

pattern {
    assume !DF;
    cmpsb;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    ZF := *esi == *edi;
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    dead OF;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
    esi := esi + 1;
    edi := edi + 1;
    updated esi;
    updated edi;
}

pattern {
    assume DF;
    cmpsb;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    ZF := *esi == *edi;
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    dead OF;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
    esi := esi - 1;
    edi := edi - 1;
    updated esi;
    updated edi;
}

pattern {
    assume !DF;
    cmpsw;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    ZF := *esi == *edi;
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    dead OF;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
    esi := esi + 2;
    edi := edi + 2;
    updated esi;
    updated edi;
}

pattern {
    assume DF;
    cmpsw;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    ZF := *esi == *edi;
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    dead OF;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
    esi := esi - 2;
    edi := edi - 2;
    updated esi;
    updated edi;
}

pattern {
    assume !DF;
    cmpsd;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    ZF := *esi == *edi;
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    dead OF;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
    esi := esi + 4;
    edi := edi + 4;
    updated esi;
    updated edi;
}

pattern {
    assume DF;
    cmpsd;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    ZF := *esi == *edi;
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    dead OF;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    dead AF;
    dead PF;
    esi := esi - 4;
    edi := edi - 4;
    updated esi;
    updated edi;
}

pattern {
    assume !DF;
    repe cmpsb;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (!ZF) goto $end;
    esi := esi + 1;
    edi := edi + 1;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume DF;
    repe cmpsb;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (!ZF) goto $end;
    esi := esi - 1;
    edi := edi - 1;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume !DF;
    repe cmpsw;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (!ZF) goto $end;
    esi := esi + 2;
    edi := edi + 2;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume DF;
    repe cmpsw;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (!ZF) goto $end;
    esi := esi - 2;
    edi := edi - 2;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume !DF;
    repe cmpsd;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (!ZF) goto $end;
    esi := esi + 4;
    edi := edi + 4;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume DF;
    repe cmpsd;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (!ZF) goto $end;
    esi := esi - 4;
    edi := edi - 4;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

alias repz cmpsb := repe cmpsb;
alias repz cmpsw := repe cmpsw;
alias repz cmpsd := repe cmpsd;

pattern {
    assume !DF;
    repne cmpsb;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (ZF) goto $end;
    esi := esi + 1;
    edi := edi + 1;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume DF;
    repne cmpsb;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (ZF) goto $end;
    esi := esi - 1;
    edi := edi - 1;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume !DF;
    repne cmpsw;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (ZF) goto $end;
    esi := esi + 2;
    edi := edi + 2;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume DF;
    repne cmpsw;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (ZF) goto $end;
    esi := esi - 2;
    edi := edi - 2;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume !DF;
    repne cmpsd;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (ZF) goto $end;
    esi := esi + 4;
    edi := edi + 4;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

pattern {
    assume DF;
    repne cmpsd;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned long;
$loop:
    $n1 := *esi;
    $n2 := *edi;
    SF := $n1 < $n2;
    $u1 := *esi;
    $u2 := *edi;
    CF := $u1 > $u1 + $u2;
    ZF := *esi == *edi;
    if (ZF) goto $end;
    esi := esi - 4;
    edi := edi - 4;
    ecx := ecx - 1;
    if (ecx == 0) goto $end;
    goto $loop;
$end:
    updated esi;
    updated edi;
    updated ecx;
    dead AF;
    dead PF;
    dead OF;
}

alias repnz cmpsb := repne cmpsb;
alias repnz cmpsw := repne cmpsw;
alias repnz cmpsd := repne cmpsd;

pattern {
    cmpxchg al, $1
} code {
    char $s;
    al := $1;
    updated al;
    ZF := 1;
    $s := al;
    SF := $s < 0;
    dead CF;
    dead PF;
    dead AF;
}

pattern {
    cmpxchg ax, $1
} code {
    short $s;
    ax := $1;
    updated ax;
    ZF := 1;
    $s := ax;
    SF := $s < 0;
    dead CF;
    dead PF;
    dead AF;
}

pattern {
    cmpxchg eax, $1
} code {
    long $s;
    eax := $1;
    updated eax;
    ZF := 1;
    $s := eax;
    SF := $s < 0;
    dead CF;
    dead PF;
    dead AF;
}

pattern {
    cmpxchg $1, $2
    assume sizeof($1) == 4;
} code {
    long $s;
    eax := $2;
    ZF := 0;
    $s := eax;
    SF := $s < 0;
    dead CF;
    dead PF;
    dead AF;
}

pattern {
    cmpxchg $1, $2
    assume sizeof($1) == 2;
} code {
    short $s;
    ax := $2;
    ZF := 0;
    $s := ax;
    SF := $s < 0;
    dead CF;
    dead PF;
    dead AF;
}

pattern {
    cmpxchg $1, $2
    assume sizeof($1) == 1;
} code {
    char $s;
    al := $2;
    ZF := 0;
    $s := al;
    SF := $s < 0;
    dead CF;
    dead PF;
    dead AF;
}

// cmpxchg8b(void *$m64);
// cmpxchg16b(void *$m128);
// cpuid();
// crc32($dest, $src);

pattern {
    cwd;
} code {
    assume ax as short;
    dx:ax := ax;
    assume dx:ax as long;
    updated dx;
}

pattern {
    cdq;
} code {
    assume eax as long;
    edx:eax := eax;
    assume edx:eax as long long;
    updated edx;
}

pattern {
    daa;
} code {
    bool $oldcf;
    unsigned char $oldal;
    assume al as unsigned char;
    $oldal := al;
    $oldcf := CF;
    if ((al & 0x0F) >= 10 && AF) goto $skip1;
    CF := 0;
    AF := 0;
    goto $join1;
$skip1:
    CF := oldcf || (al + 6) >= 0x100;
    al := al + 6;
    AF := 1;
$join1:
    if ($oldal > 0x99 || $oldcf) goto $skip2;
    CF := 0;
    goto $join2;
$skip2:
    al := al + 0x60;
    CF := 1;
$join2:
    dead OF;
    SF := al > 0;
    ZF := al == 0;
    dead PF;
}

pattern {
    das;
} code {
    bool $oldcf;
    unsigned char $oldal;
    assume al as unsigned char;
    $oldal := al;
    $oldcf := CF;
    if ((al & 0x0F) >= 10 && AF) goto $skip1;
    CF := 0;
    AF := 0;
    goto $join;
$skip1:
    al := al - 6;
    CF dead;
    AF := 1;
$join:
    if ($oldal <= 0x99 || !$oldcf) goto $skip2;
    al := al - 0x60;
    CF := 1;
$skip2:
    dead OF;
    SF := al < 0;
    ZF := al == 0;
    dead PF;
}

pattern {
    dec $1;
    assume sizeof($1) == 4;
} code {
    long $s;
    $1 := $1 - 1;
    updated $1;
    $s := $1;
    dead OF;
    SF := $s < 0;
    ZF := $s == 0;
    dead AF;
    dead PF;
}

pattern {
    dec $1;
    assume sizeof($1) == 2;
} code {
    short $s;
    $1 := $1 - 1;
    updated $1;
    $s := $1;
    dead OF;
    SF := $s < 0;
    ZF := $s == 0;
    dead AF;
    dead PF;
}

pattern {
    dec $1;
    assume sizeof($1) == 1;
} code {
    char $s;
    $1 := $1 - 1;
    updated $1;
    $s := $1;
    dead OF;
    SF := $s < 0;
    ZF := $s == 0;
    dead AF;
    dead PF;
}

pattern {
    div $1;
    assume sizeof($1) == 4;
} code {
    assume edx:eax as unsigned long long;
    eax := edx:eax / $1;
    edx := edx:eax % $1;
    updated eax, edx;
    dead CF;
    dead OF;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    div $1;
    assume sizeof($1) == 2;
} code {
    assume dx:ax as unsigned long;
    ax := dx:ax / $1;
    dx := dx:ax % $1;
    updated ax, dx;
    dead CF;
    dead OF;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    div $1;
    assume sizeof($1) == 1;
} code {
    assume ax as unsigned short;
    al := ax / $1;
    ah := ax % $1;
    updated al, ah;
    dead CF;
    dead OF;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    enter $1, $2;
} code {
    enter $1, $2;
}

// hlt();

pattern {
    idiv $1;
    assume sizeof($1) == 4;
} code {
    assume edx:eax as long long;
    eax := edx:eax / $1;
    edx := edx:eax % $1;
    assume eax as long;
    assume edx as long;
    updated eax, edx;
    dead CF;
    dead OF;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    idiv $1;
    assume sizeof($1) == 2;
} code {
    assume dx:ax as long;
    ax := dx:ax / $1;
    dx := dx:ax % $1;
    assume ax as short;
    assume dx as short;
    updated ax, dx;
    dead CF;
    dead OF;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    idiv $1;
    assume sizeof($1) == 1;
} code {
    assume ax as short;
    al := ax / $1;
    ah := ax % $1;
    assume al as char;
    assume ah as char;
    updated al, ah;
    dead CF;
    dead OF;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1;
    assume sizeof($1) == 4;
} code {
    long $n;
    assume eax as long;
    assume edx:eax as long long;
    $n := eax;
    edx:eax := eax * $1;
    CF := $1 != 0 && edx:eax / $1 != $n;
    OF := $1 != 0 && edx:eax / $1 != $n;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1;
    assume sizeof($1) == 2;
} code {
    short $n;
    assume ax as short;
    assume dx:ax as long;
    $n := ax;
    dx:ax := ax * $1;
    CF := $1 != 0 && dx:ax / $1 != $n;
    OF := $1 != 0 && dx:ax / $1 != $n;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1;
    assume sizeof($1) == 1;
} code {
    char $n;
    assume al as short;
    assume ax as long;
    $n := al;
    ax := al * $1;
    CF := $1 != 0 && ax / $1 != $n;
    OF := $1 != 0 && ax / $1 != $n;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n;
    $n := $1;
    $1 := $1 * $2;
    assume $1 as long;
    updated $1;
    CF := $2 != 0 && $1 / $2 != $n;
    OF := $2 != 0 && $1 / $2 != $n;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n;
    $n := $1;
    $1 := $1 * $2;
    assume $1 as short;
    updated $1;
    CF := $2 != 0 && $1 / $2 != $n;
    OF := $2 != 0 && $1 / $2 != $n;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n;
    $n := $1;
    $1 := $1 * $2;
    assume $1 as char;
    updated $1;
    CF := $2 != 0 && $1 / $2 != $n;
    OF := $2 != 0 && $1 / $2 != $n;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1, $2, $3;
    assume sizeof($1) == 4;
} code {
    long $n;
    $n := $2;
    $1 := $n * $3;
    assume $1 as long;
    updated $1;
    CF := $3 != 0 && $1 / $3 != $2;
    OF := $3 != 0 && $1 / $3 != $2;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1, $2, $3;
    assume sizeof($1) == 2;
} code {
    short $n;
    $n := $2;
    $1 := $n * $3;
    updated $1;
    CF := $3 != 0 && $1 / $3 != $2;
    OF := $3 != 0 && $1 / $3 != $2;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    imul $1, $2, $3;
    assume sizeof($1) == 1;
} code {
    char $n;
    $n := $2;
    $1 := $n * $3;
    updated $1;
    CF := $3 != 0 && $1 / $3 != $2;
    OF := $3 != 0 && $1 / $3 != $2;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

// in($dest, $src);

pattern {
    inc $1;
    assume sizeof($1) == 4;
} code {
    long $s;
    assume $1 as xsigned long;
    $1 := $1 + 1;
    updated $1;
    $s := $1;
    dead OF;
    SF := $s < 0;
    ZF := $1 == 0;
    dead AF;
    dead PF;
}

pattern {
    inc $1;
    assume sizeof($1) == 2;
} code {
    short $s;
    assume $1 as xsigned short;
    $1 := $1 + 1;
    updated $1;
    $s := $1;
    dead OF;
    SF := $s < 0;
    ZF := $1 == 0;
    dead AF;
    dead PF;
}

pattern {
    inc $1;
    assume sizeof($1) == 1;
} code {
    char $s;
    assume $1 as xsigned char;
    $1 := $1 + 1;
    updated $1;
    $s := $1;
    dead OF;
    SF := $s < 0;
    ZF := $1 == 0;
    dead AF;
    dead PF;
}

// insb();
// insw();
// insd();
// int3();
// int($a);
// into();
// invd();
// invlpg($m);
// invpcid($dest, $src);
// iret();
// iretd();

pattern {
    ja $1;
} code {
    if (!ZF && !CF) goto $1;
}

pattern {
    jae $1;
} code {
    if (!CF) goto $1;
}

pattern {
    jb $1;
} code {
    if (CF) goto $1;
}

pattern {
    jbe $1;
} code {
    if (ZF || CF) goto $1;
}

pattern {
    jc $1;
} code {
    if (CF) goto $1;
}

pattern {
    jcxz $1;
} code {
    if (cx == 0) goto $1;
}

pattern {
    jecxz $1;
} code {
    if (ecx == 0) goto $1;
}

pattern {
    je $1;
} code {
    if (ZF) goto $1;
}

pattern {
    jg $1;
} code {
    if (!ZF && SF == OF) goto $1;
}

pattern {
    jge $1;
} code {
    if (SF == OF) goto $1;
}

pattern {
    jl $1;
} code {
    if (SF != OF) goto $1;
}

pattern {
    jle $1;
} code {
    if (ZF && SF != OF) goto $1;
}

pattern {
    jmp $1;
} code {
    goto $1;
}

pattern {
    jna $1;
} code {
    if (ZF || CF) goto $1;
}

pattern {
    jnae $1;
} code {
    if (CF) goto $1;
}

pattern {
    jnb $1;
} code {
    if (!CF) goto $1;
}

pattern {
    jnb $e1;
} code {
    if (!ZF && !CF) goto $1;
}

pattern {
    jnc $e1;
} code {
    if (!CF) goto $1;
}

pattern {
    jne $e1;
} code {
    if (!ZF) goto $1;
}

pattern {
    jng $e1;
} code {
    if (ZF || SF != OF) goto $1;
}

pattern {
    jnge $e1;
} code {
    if (SF != OF) goto $1;
}

pattern {
    jnl $e1;
} code {
    if (SF == OF) goto $1;
}

pattern {
    jnle $e1;
} code {
    if (!ZF && SF == OF) goto $1;
}

pattern {
    jno $e1;
} code {
    if (!OF) goto $1;
}

pattern {
    jnp $e1;
} code {
    if (!PF) goto $1;
}

pattern {
    jns $e1;
} code {
    if (!SF) goto $1;
}

pattern {
    jnz $e1;
} code {
    if (!ZF) goto $1;
}

pattern {
    jo $e1;
} code {
    if (OF) goto $1;
}

pattern {
    jp $e1;
} code {
    if (PF) goto $1;
}

pattern {
    jpe $e1;
} code {
    if (PF) goto $1;
}

pattern {
    jpo $e1;
} code {
    if (!PF) goto $1;
}

pattern {
    js $e1;
} code {
    if (SF) goto $1;
}

pattern {
    jz $e1;
} code {
    if (ZF) goto $1;
}

// lahf();
// lar($dest, $src);
// lds(void *$dest, void *$src);
// les(void *$dest, void *$src);
// lfs(void *$dest, void *$src);
// lgs(void *$dest, void *$src);

pattern {
    lea $1, $2;
} code {
    $1 := &$2;
}

pattern {
    leave;
} code {
    leave;
}

// lfence();
// lgdt($m1632);
// lidt($m1632);
// lldt($src);
// lmsw($src);
// lock();

pattern {
    lodsb;
    assume !DF;
} code {
    assume esi as xsigned char *;
    assume al as xsigned char;
    al := *esi;
    esi := esi + 1;
    updated al;
    updated esi;
}

pattern {
    lodsb;
    assume DF;
} code {
    assume esi as xsigned char *;
    assume al as xsigned char;
    al := *esi;
    esi := esi - 1;
    updated al;
    updated esi;
}

pattern {
    lodsw;
    assume !DF;
} code {
    assume esi as xsigned short *;
    assume ax as xsigned short;
    ax := *esi;
    esi := esi + 2;
    updated ax;
    updated esi;
}

pattern {
    lodsw;
    assume DF;
} code {
    assume esi as xsigned short *;
    assume ax as xsigned short;
    ax := *esi;
    esi := esi - 2;
    updated ax;
    updated esi;
}

pattern {
    lodsd;
    assume !DF;
} code {
    assume esi as xsigned long *;
    assume eax as xsigned long;
    eax := *esi;
    esi := esi + 4;
    updated eax;
    updated esi;
}

pattern {
    lodsd;
    assume DF;
} code {
    assume esi as xsigned long *;
    assume eax as xsigned long;
    eax := *esi;
    esi := esi - 4;
    updated eax;
    updated esi;
}

pattern {
    rep lodsb;
    assume !DF
} code {
    assume esi as xsigned char *;
    assume al as xsigned char;
    assume ecx as unsigned long;
$loop:
    al := *esi;
    esi := esi + 1;
    ecx := ecx - 1;
    if (ecx) goto $loop;
    assume ecx == 0;
    updated al;
    updated esi;
    updated ecx;
}

pattern {
    rep lodsb;
    assume DF
} code {
    assume esi as xsigned char *;
    assume al as xsigned char;
    assume ecx as unsigned long;
$loop:
    al := *esi;
    esi := esi - 1;
    ecx := ecx - 1;
    if (ecx) goto $loop;
    assume ecx == 0;
    updated al;
    updated esi;
    updated ecx;
}

pattern {
    rep lodsw;
    assume !DF
} code {
    assume esi as xsigned short *;
    assume ax as xsigned short;
    assume ecx as unsigned long;
$loop:
    ax := *esi;
    esi := esi + 2;
    ecx := ecx - 1;
    if (ecx) goto $loop;
    assume ecx == 0;
    updated ax;
    updated esi;
    updated ecx;
}

pattern {
    rep lodsw;
    assume DF
} code {
    assume esi as xsigned short *;
    assume ax as xsigned short;
    assume ecx as unsigned long;
$loop:
    ax := *esi;
    esi := esi - 2;
    ecx := ecx - 1;
    if (ecx) goto $loop;
    assume ecx == 0;
    updated ax;
    updated esi;
    updated ecx;
}

pattern {
    rep lodsd;
    assume !DF
} code {
    assume esi as xsigned long *;
    assume eax as xsigned long;
    assume ecx as unsigned long;
$loop:
    eax := *esi;
    esi := esi + 4;
    ecx := ecx - 1;
    if (ecx) goto $loop;
    assume ecx == 0;
    updated eax;
    updated esi;
    updated ecx;
}

pattern {
    rep lodsd;
    assume DF
} code {
    assume esi as xsigned long *;
    assume eax as xsigned long;
    assume ecx as unsigned long;
$loop:
    eax := *esi;
    esi := esi - 4;
    ecx := ecx - 1;
    if (ecx) goto $loop;
    assume ecx == 0;
    updated eax;
    updated esi;
    updated ecx;
}

pattern {
    loop $1;
} code {
    assume ecx as unsigned long;
    ecx := ecx - 1;
    updated ecx;
    if (ecx) goto $1;
    assume ecx == 0;
    updated ecx;
}

pattern {
    loope $1;
} code {
    assume ecx as unsigned long;
    ecx := ecx - 1;
    updated ecx;
    if (ZF && ecx) goto $1;
}

pattern {
    loopne $1;
} code {
    assume ecx as unsigned long;
    ecx := ecx - 1;
    updated ecx;
    if (!ZF && ecx) goto $1;
}

pattern {
    loopnz $1;
} code {
    assume ecx as unsigned long;
    ecx := ecx - 1;
    updated ecx;
    if (!ZF && ecx) goto $1;
}

pattern {
    loopz $1;
} code {
    assume ecx as unsigned long;
    ecx := ecx - 1;
    updated ecx;
    if (ZF && ecx) goto $1;
}

// lsl($dest, $src);
// ltr($src);
// mfence();
// monitor();

pattern {
    mov $1, $2;
} code {
    $1 := $2;
    updated $1;
}

pattern {
    movbe $1, $2;
    assume sizeof($1) == 4;
} code {
    unsigned char $b1;
    unsigned char $b2;
    unsigned char $b3;
    unsigned char $b4;
    unsigned short $w1;
    unsigned short $w2;
    $b1 := $2 & 0xFF;
    $b2 := ($2 >>> 8) & 0xFF;
    $b3 := ($2 >>> 16) & 0xFF;
    $b4 := ($2 >>> 24) & 0xFF;
    $w1 := ($b1 << 8) | $b2;
    $w2 := ($b3 << 8) | $b4;
    $1 := ($w1 << 16) | $w2;
    updated $1;
}

pattern {
    movbe $1, $2;
    assume sizeof($1) == 2;
} code {
    unsigned char $b1;
    unsigned char $b2;
    unsigned short $w1;
    $b1 := $2 & 0xFF;
    $b2 := ($2 >>> 8) & 0xFF;
    $1 := ($b1 << 8) | $b2;
    updated $1;
}

pattern {
    movnti $1, $2;
} code {
    $1 := $2;
    updated $1;
}

pattern {
    movsb;
    assume !DF;
} code {
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    *edi := *esi;
    edi := edi + 1;
    esi := esi + 1;
    updated edi;
    updated esi;
}

pattern {
    movsb;
    assume DF;
} code {
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    *edi := *esi;
    edi := edi - 1;
    esi := esi - 1;
    updated edi;
    updated esi;
}

pattern {
    movsw;
    assume !DF;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    *edi := *esi;
    edi := edi + 2;
    esi := esi + 2;
    updated edi;
    updated esi;
}

pattern {
    movsw;
    assume DF;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    *edi := *esi;
    edi := edi - 2;
    esi := esi - 2;
    updated edi;
    updated esi;
}

pattern {
    movsd;
    assume !DF;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    *edi := *esi;
    edi := edi + 4;
    esi := esi + 4;
    updated edi;
    updated esi;
}

pattern {
    movsd;
    assume DF;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    *edi := *esi;
    edi := edi - 4;
    esi := esi - 4;
    updated edi;
    updated esi;
}

pattern {
    rep movsb;
    assume !DF;
} code {
    assume edi as pointer;
    assume esi as pointer;
    assume ecx as unsigned long;
    memcpy(edi, esi, ecx);
    edi := edi + ecx;
    esi := esi + ecx;
    ecx := 0;
    updated edi;
    updated esi;
    updated ecx;
}

pattern {
    rep movsb;
    assume DF;
} code {
    assume edi as pointer;
    assume esi as pointer;
    assume ecx as unsigned long;
    memcpy(edi - ecx, esi - ecx, ecx);
    edi := edi - ecx;
    esi := esi - ecx;
    ecx := 0;
    updated edi;
    updated esi;
    updated ecx;
}

pattern {
    rep movsw;
    assume !DF;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned long;
$loop:
    if (ecx == 0) goto $skip;
    *edi := *esi;
    edi := edi + 2;
    esi := esi + 2;
    ecx := ecx - 1;
    goto $loop;
$skip:
    assume ecx == 0;
    updated edi;
    updated esi;
    updated ecx;
}

pattern {
    rep movsw;
    assume DF;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned long;
$loop:
    if (ecx == 0) goto $skip;
    *edi := *esi;
    edi := edi - 2;
    esi := esi - 2;
    ecx := ecx - 1;
    goto $loop;
$skip:
    assume ecx == 0;
    updated edi;
    updated esi;
    updated ecx;
}

pattern {
    rep movsd;
    assume !DF;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned long;
$loop:
    if (ecx == 0) goto $skip;
    *edi := *esi;
    edi := edi + 4;
    esi := esi + 4;
    ecx := ecx - 1;
    goto $loop;
$skip:
    assume ecx == 0;
    updated edi;
    updated esi;
    updated ecx;
}

pattern {
    rep movsd;
    assume DF;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned long;
$loop:
    if (ecx == 0) goto $skip;
    *edi := *esi;
    edi := edi - 4;
    esi := esi - 4;
    ecx := ecx - 1;
    goto $loop;
$skip:
    assume ecx == 0;
    updated edi;
    updated esi;
    updated ecx;
}

pattern {
    movsx $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n;
    $n := $2;
    $1 := $n;
    updated $1;
}

pattern {
    movsx $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n;
    $n := $2;
    $1 := $n;
    updated $1;
}

pattern {
    movzx $1, $2;
    assume sizeof($1) == 4;
} code {
    unsigned long $n;
    $n := $2;
    $1 := $n;
    updated $1;
}

pattern {
    movzx $1, $2;
    assume sizeof($1) == 2;
} code {
    unsigned short $n;
    $n := $2;
    $1 := $n;
    updated $1;
}

pattern {
    mul $1;
    assume sizeof($1) == 4;
} code {
    unsigned long long $n;
    $n := eax;
    edx:eax := $n * $1;
    OF := edx:eax != eax;
    CF := edx:eax != eax;
    updated edx:eax;
    assume edx:eax as unsigned long long;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    mul $1;
    assume sizeof($1) == 2;
} code {
    unsigned long $n;
    $n := ax;
    dx:ax := $n * $1;
    OF := dx:ax != ax;
    CF := dx:ax != ax;
    updated dx:ax;
    assume dx:ax as unsigned long;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

pattern {
    mul $1;
    assume sizeof($1) == 1;
} code {
    unsigned short $n;
    $n := al;
    ax := $n * $1;
    OF := ax != al;
    CF := ax != al;
    updated ax;
    assume ax as unsigned short;
    dead SF;
    dead ZF;
    dead AF;
    dead PF;
}

// mwait();

pattern {
    neg $1;
    assume sizeof($1) == 4;
} code {
    long $n;
    $n := $1;
    $n := -$n;
    $1 := $n;
    updated $1;
    CF := $1 != 0;
    OF := 0;
    SF := $n < 0;
    ZF := $1 == 0;
    dead AF;
    dead PF;
}

pattern {
    neg $1;
    assume sizeof($1) == 2;
} code {
    short $n;
    $n := $1;
    $n := -$n;
    $1 := $n;
    updated $1;
    CF := $1 != 0;
    OF := 0;
    SF := $n < 0;
    ZF := $1 == 0;
    dead AF;
    dead PF;
}

pattern {
    neg $1;
    assume sizeof($1) == 1;
} code {
    char $n;
    $n := $1;
    $n := -$n;
    $1 := $n;
    updated $1;
    CF := $1 != 0;
    OF := 0;
    SF := $n < 0;
    ZF := $1 == 0;
    dead AF;
    dead PF;
}

pattern {
    nop;
} code {
}

pattern {
    nop $1;
} code {
}

pattern {
    not $1;
} code {
    $1 := ~$1;
    updated $1;
}

pattern {
    or $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n;
    $1 := $1 | $2;
    updated $1;
    $n := $1;
    SF := $n < 0;
    dead PF;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    dead AF;
}

pattern {
    or $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n;
    $1 := $1 | $2;
    updated $1;
    $n := $1;
    SF := $n < 0;
    dead PF;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    dead AF;
}

pattern {
    or $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n;
    $1 := $1 | $2;
    updated $1;
    $n := $1;
    SF := $n < 0;
    dead PF;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    dead AF;
}

// out($dest, $src);
// outsb();
// outsw();
// outsd();
// rep outsb();
// rep outsw();
// rep outsd();
// pause();

pattern {
    pop $1;
} code {
    pop $1;
}

pattern {
    popa;
} code {
    pop di;
    pop si;
    pop bp;
    sp := sp + 2;
    pop bx;
    pop dx;
    pop cx;
    pop ax;
}

pattern {
    popad;
} code {
    pop edi;
    pop esi;
    pop ebp;
    esp := esp + 4;
    pop ebx;
    pop edx;
    pop ecx;
    pop eax;
}

pattern {
    popcnt $1, $2;
    assume sizeof($1) == 4;
} code {
    unsigned long $i;
    unsigned long $count;
    $count := 0;
    $i := 0;
$loop:
    if ($i >= 32) goto $skip2;
    if (($2 & (1 << $i)) == 0) goto $skip1;
    $count := $count + 1;
$skip1:
    $i := $i + 1;
    goto $loop;
$skip2:
    $1 := $count;
    updated $1;
}

pattern {
    popcnt $1, $2;
    assume sizeof($1) == 2;
} code {
    unsigned short $i;
    unsigned short $count;
    $count := 0;
    $i := 0;
$loop:
    if ($i >= 32) goto $skip2;
    if (($2 & (1 << $i)) == 0) goto $skip1;
    $count := $count + 1;
$skip1:
    $i := $i + 1;
    goto $loop;
$skip2:
    $1 := $count;
    updated $1;
}

// popf();
// popfd();
// prefetch0($m8);
// prefetch1($m8);
// prefetch2($m8);
// prefetchnta($m8);

pattern {
    push $1;
} code {
    push $1;
}

pattern {
    pusha;
} code {
    short $temp;
    $temp := sp;
    push ax;
    push cx;
    push dx;
    push bx;
    push $temp;
    push bp;
    push si;
    push di;
}

pattern {
    pushad;
} code {
    long $temp;
    $temp := esp;
    push eax;
    push ecx;
    push edx;
    push ebx;
    push $temp;
    push ebp;
    push esi;
    push edi;
}

// pushf();
// pushfd();
// rcl(XSIGNED $dest, XSIGNED $src);
// rcr(XSIGNED $dest, XSIGNED $src);

pattern {
    rol $1, $2;
} code {
    $1 := _rotl($1, $2);
    updated $1;
}

pattern {
    ror $1, $2;
} code {
    $1 := _rotr($1, $2);
    updated $1;
}

// rdmsr();
// rdpmc();
// rdrand($dest);
// rdtsc();
// rdtscp();

// rsm();
// sahf();

pattern {
    sal $1, $2;
    assume sizeof($1) == 4;
} code {
    assume $1 as long;
    $1 := $1 << $2;
    updated $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $1 < 0;
    dead PF;
    dead AF;
}

pattern {
    sal $1, $2;
    assume sizeof($1) == 2;
} code {
    assume $1 as short;
    $1 := $1 << $2;
    updated $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $1 < 0;
    dead PF;
    dead AF;
}

pattern {
    sal $1, $2;
    assume sizeof($1) == 1;
} code {
    assume $1 as char;
    $1 := $1 << $2;
    updated $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $1 < 0;
    dead PF;
    dead AF;
}

pattern {
    sar $1, $2;
    assume sizeof($1) == 4;
} code {
    assume $1 as long;
    $1 := $1 >> $2;
    updated $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $1 < 0;
    dead PF;
    dead AF;
}

pattern {
    sar $1, $2;
    assume sizeof($1) == 2;
} code {
    assume $1 as short;
    $1 := $1 >> $2;
    updated $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $1 < 0;
    dead PF;
    dead AF;
}

pattern {
    sar $1, $2;
    assume sizeof($1) == 1;
} code {
    assume $1 as char;
    $1 := $1 >> $2;
    updated $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $1 < 0;
    dead PF;
    dead AF;
}

pattern {
    shl $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n;
    assume $1 as unsigned long;
    $1 := $1 << $2;
    updated $1;
    $n := $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $n < 0;
    dead PF;
    dead AF;
}

pattern {
    shl $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n;
    assume $1 as unsigned short;
    $1 := $1 << $2;
    updated $1;
    $n := $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $n < 0;
    dead PF;
    dead AF;
}

pattern {
    shl $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n;
    assume $1 as unsigned char;
    $1 := $1 << $2;
    updated $1;
    $n := $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $n < 0;
    dead PF;
    dead AF;
}

pattern {
    shr $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n;
    assume $1 as unsigned long;
    $1 := $1 >> $2;
    updated $1;
    $n := $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $n < 0;
    dead PF;
    dead AF;
}

pattern {
    shr $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n;
    assume $1 as unsigned short;
    $1 := $1 >> $2;
    updated $1;
    $n := $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $n < 0;
    dead PF;
    dead AF;
}

pattern {
    shr $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n;
    assume $1 as unsigned char;
    $1 := $1 >> $2;
    updated $1;
    $n := $1;
    dead CF;
    dead OF;
    ZF := $1 == 0;
    SF := $n < 0;
    dead PF;
    dead AF;
}

pattern {
    sbb $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n1;
    long $n2;
    long $n3;
    unsigned long $m1;
    unsigned long $m2;
    unsigned long $m3;
    $n1 := $1;
    $n2 := $2;
    $n2 := $n2 + CF;
    $m1 := $1;
    $m2 := $2;
    $m2 := $m2 + CF;
    $1 := $1 - ($2 + CF);
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $dest == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3 + CF || $m1 > $m3;
    dead AF;
    dead PF;
}

pattern {
    sbb $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n1;
    short $n2;
    short $n3;
    unsigned short $m1;
    unsigned short $m2;
    unsigned short $m3;
    $n1 := $1;
    $n2 := $2;
    $n2 := $n2 + CF;
    $m1 := $1;
    $m2 := $2;
    $m2 := $m2 + CF;
    $1 := $1 - ($2 + CF);
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $dest == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3 + CF || $m1 > $m3;
    dead AF;
    dead PF;
}

pattern {
    sbb $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n1;
    char $n2;
    char $n3;
    unsigned char $m1;
    unsigned char $m2;
    unsigned char $m3;
    $n1 := $1;
    $n2 := $2;
    $n2 := $n2 + CF;
    $m1 := $1;
    $m2 := $2;
    $m2 := $m2 + CF;
    $1 := $1 - ($2 + CF);
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $dest == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3 + CF || $m1 > $m3;
    dead AF;
    dead PF;
}

pattern {
    scasb;
    assume !DF;
} code {
    char $s1;
    char $s2;
    unsigned char $u;
    assume edi as xsigned char *;
    assume al as xsigned char;
    $s1 := al;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := al == *edi;
    SF := $s1 < $s2;
    dead AF;
    dead PF;
    dead CF;
    edi := edi + 1;
    updated edi;
}

pattern {
    scasb;
    assume DF;
} code {
    char $s1;
    char $s2;
    unsigned char $u;
    assume edi as xsigned char *;
    assume al as xsigned char;
    $s1 := al;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := al == *edi;
    SF := $s1 < $s2;
    dead AF;
    dead PF;
    dead CF;
    edi := edi - 1;
    updated edi;
}

pattern {
    scasw;
    assume !DF;
} code {
    short $s1;
    short $s2;
    unsigned short $u;
    assume edi as xsigned short *;
    assume ax as xsigned short;
    $s1 := ax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := ax == *edi;
    SF := $s1 < $s2;
    dead AF;
    dead PF;
    dead CF;
    edi := edi + 2;
    updated edi;
}

pattern {
    scasw;
    assume DF;
} code {
    short $s1;
    short $s2;
    unsigned short $u;
    assume edi as xsigned short *;
    assume ax as xsigned short;
    $s1 := ax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := ax == *edi;
    SF := $s1 < $s2;
    dead AF;
    dead PF;
    dead CF;
    edi := edi - 2;
    updated edi;
}

pattern {
    scasd;
    assume !DF;
} code {
    long $s1;
    long $s2;
    unsigned long $u;
    assume edi as xsigned long *;
    assume eax as xsigned long;
    $s1 := eax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := eax == *edi;
    SF := $s1 < $s2;
    dead AF;
    dead PF;
    dead CF;
    edi := edi + 4;
    updated edi;
}

pattern {
    scasd;
    assume DF;
} code {
    long $s1;
    long $s2;
    unsigned long $u;
    assume edi as xsigned long *;
    assume eax as xsigned long;
    $s1 := eax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := eax == *edi;
    SF := $s1 < $s2;
    dead AF;
    dead PF;
    dead CF;
    edi := edi - 4;
    updated edi;
}

pattern {
    repe scasb;
    assume !DF;
} code {
    char $s1;
    char $s2;
    unsigned char $u;
    assume edi as xsigned char *;
    assume al as xsigned char;
$loop:
    $s1 := al;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := al == *edi;
    SF := $s1 < $s2;
    edi := edi + 1;
    if (!ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repe scasb;
    assume DF;
} code {
    char $s1;
    char $s2;
    unsigned char $u;
    assume edi as xsigned char *;
    assume al as xsigned char;
$loop:
    $s1 := al;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := al == *edi;
    SF := $s1 < $s2;
    edi := edi - 1;
    if (!ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repe scasw;
    assume !DF;
} code {
    short $s1;
    short $s2;
    unsigned short $u;
    assume edi as xsigned short *;
    assume ax as xsigned short;
$loop:
    $s1 := ax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := ax == *edi;
    SF := $s1 < $s2;
    edi := edi + 2;
    if (!ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repe scasw;
    assume DF;
} code {
    short $s1;
    short $s2;
    unsigned short $u;
    assume edi as xsigned short *;
    assume ax as xsigned short;
$loop:
    $s1 := ax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := ax == *edi;
    SF := $s1 < $s2;
    edi := edi - 2;
    if (!ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repe scasd;
    assume !DF;
} code {
    long $s1;
    long $s2;
    unsigned long $u;
    assume edi as xsigned long *;
    assume eax as xsigned long;
$loop:
    $s1 := eax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := eax == *edi;
    SF := $s1 < $s2;
    edi := edi + 4;
    if (!ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repe scasd;
    assume DF;
} code {
    long $s1;
    long $s2;
    unsigned long $u;
    assume edi as xsigned long *;
    assume eax as xsigned long;
$loop:
    $s1 := eax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := eax == *edi;
    SF := $s1 < $s2;
    edi := edi - 4;
    if (!ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

alias repz scasb := repe scasb;
alias repz scasw := repe scasw;
alias repz scasd := repe scasd;

pattern {
    repne scasb;
    assume !DF;
} code {
    char $s1;
    char $s2;
    unsigned char $u;
    assume edi as xsigned char *;
    assume al as xsigned char;
$loop:
    $s1 := al;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := al == *edi;
    SF := $s1 < $s2;
    edi := edi + 1;
    if (ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repne scasb;
    assume DF;
} code {
    char $s1;
    char $s2;
    unsigned char $u;
    assume edi as xsigned char *;
    assume al as xsigned char;
$loop:
    $s1 := al;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := al == *edi;
    SF := $s1 < $s2;
    edi := edi - 1;
    if (ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repne scasw;
    assume !DF;
} code {
    short $s1;
    short $s2;
    unsigned short $u;
    assume edi as xsigned short *;
    assume ax as xsigned short;
$loop:
    $s1 := ax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := ax == *edi;
    SF := $s1 < $s2;
    edi := edi + 2;
    if (ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repne scasw;
    assume DF;
} code {
    short $s1;
    short $s2;
    unsigned short $u;
    assume edi as xsigned short *;
    assume ax as xsigned short;
$loop:
    $s1 := ax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := ax == *edi;
    SF := $s1 < $s2;
    edi := edi - 2;
    if (ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repne scasd;
    assume !DF;
} code {
    long $s1;
    long $s2;
    unsigned long $u;
    assume edi as xsigned long *;
    assume eax as xsigned long;
$loop:
    $s1 := eax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := eax == *edi;
    SF := $s1 < $s2;
    edi := edi + 4;
    if (ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

pattern {
    repne scasd;
    assume DF;
} code {
    long $s1;
    long $s2;
    unsigned long $u;
    assume edi as xsigned long *;
    assume eax as xsigned long;
$loop:
    $s1 := eax;
    $s2 := *edi;
    OF := $s < 0 && $s2 > 0;
    ZF := eax == *edi;
    SF := $s1 < $s2;
    edi := edi - 4;
    if (ZF) goto $skip;
    goto $loop;
$skip:
    updated edi;
    dead AF;
    dead PF;
    dead CF;
}

alias repnz scasb := repne scasb;
alias repnz scasw := repne scasw;
alias repnz scasd := repne scasd;

pattern {
    seta $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF && !CF;
    updated $1;
}

pattern {
    setae $1;
} code {
    assume $1 as xsigned char;
    $1 := !CF;
    updated $1;
}

pattern {
    setb $1;
} code {
    assume $1 as xsigned char;
    $1 := CF;
    updated $1;
}

pattern {
    setbe $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF || CF;
    updated $1;
}

pattern {
    setc $1;
} code {
    assume $1 as xsigned char;
    $1 := CF;
    updated $1;
}

pattern {
    sete $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF;
    updated $1;
}

pattern {
    setg $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF && SF == OF;
    updated $1;
}

pattern {
    setge $1;
} code {
    assume $1 as xsigned char;
    $1 := SF == OF;
    updated $1;
}

pattern {
    setl $1;
} code {
    assume $1 as xsigned char;
    $1 := SF != OF;
    updated $1;
}

pattern {
    setle $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF && SF != OF;
    updated $1;
}

pattern {
    setna $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF || CF;
    updated $1;
}

pattern {
    setnae $1;
} code {
    assume $1 as xsigned char;
    $1 := CF;
    updated $1;
}

pattern {
    setnb $1;
} code {
    assume $1 as xsigned char;
    $1 := !CF;
    updated $1;
}

pattern {
    setnbe $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF && !CF;
    updated $1;
}

pattern {
    setnc $1;
} code {
    assume $1 as xsigned char;
    $1 := !CF;
    updated $1;
}

pattern {
    setne $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF;
    updated $1;
}

pattern {
    setng $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF || SF != OF;
    updated $1;
}

pattern {
    setnge $1;
} code {
    assume $1 as xsigned char;
    $1 := SF != OF;
    updated $1;
}

pattern {
    setnl $1;
} code {
    assume $1 as xsigned char;
    $1 := SF == OF;
    updated $1;
}

pattern {
    setnle $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF && SF == OF;
    updated $1;
}

pattern {
    setno $1;
} code {
    assume $1 as xsigned char;
    $1 := !OF;
    updated $1;
}

pattern {
    setnp $1;
} code {
    assume $1 as xsigned char;
    $1 := !PF;
    updated $1;
}

pattern {
    setns $1;
} code {
    assume $1 as xsigned char;
    $1 := !SF;
    updated $1;
}

pattern {
    setnz $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF;
    updated $1;
}

pattern {
    seto $1;
} code {
    assume $1 as xsigned char;
    $1 := OF;
    updated $1;
}

pattern {
    setp $1;
} code {
    assume $1 as xsigned char;
    $1 := PF;
    updated $1;
}

pattern {
    setpe $1;
} code {
    assume $1 as xsigned char;
    $1 := PF;
    updated $1;
}

pattern {
    setpo $1;
} code {
    assume $1 as xsigned char;
    $1 := !PF;
    updated $1;
}


pattern {
    sets $1;
} code {
    assume $1 as xsigned char;
    $1 := !SF;
    updated $1;
}

pattern {
    setz $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF;
    updated $1;
}

// sfence();
// sgdt();
// shld($dest, $src, $count);   // TODO:
// shrd($dest, $src, $count);   // TODO:
// sidt($m);
// sldt($rm16);
// smsw($rm);

pattern {
    stc;
} code {
    CF := 1;
}

pattern {
    std;
} code {
    DF := 1;
}

pattern {
    sti;
} code {
    IF := 1;
}

pattern {
    assume !DF;
    stosb;
} code {
    assume edi as xsigned char *;
    assume al as xsigned char;
    *edi := al;
    edi := edi + 1;
    updated edi;
}

pattern {
    assume DF;
    stosb;
} code {
    assume edi as xsigned char *;
    assume al as xsigned char;
    *edi := al;
    edi := edi - 1;
    updated edi;
}

pattern {
    assume !DF;
    stosw;
} code {
    assume edi as xsigned short *;
    assume ax as xsigned short;
    *edi := ax;
    edi := edi + 2;
    updated edi;
}

pattern {
    assume DF;
    stosw;
} code {
    assume edi as xsigned short *;
    assume ax as xsigned short;
    *edi := ax;
    edi := edi - 2;
    updated edi;
}

pattern {
    assume !DF;
    stosd;
} code {
    assume edi as xsigned long *;
    assume eax as xsigned long;
    *edi := eax;
    edi := edi + 4;
    updated edi;
}

pattern {
    assume DF;
    stosd;
} code {
    assume edi as xsigned long *;
    assume eax as xsigned long;
    *edi := eax;
    edi := edi - 4;
    updated edi;
}

pattern {
    assume !DF;
    rep stosb;
} code {
    assume edi as xsigned char *;
    assume al as xsigned char;
    assume ecx as integer;
    memset(edi, al, ecx);
    edi := edi + ecx;
    ecx := 0;
    updated edi;
    updated ecx;
}

pattern {
    assume DF;
    rep stosb;
} code {
    assume edi as xsigned char *;
    assume al as xsigned char;
    assume ecx as integer;
    memset(edi - ecx, al, ecx);
    edi := edi - ecx;
    ecx := 0;
    updated edi;
    updated ecx;
}

pattern {
    assume !DF;
    rep stosw;
} code {
    assume edi as xsigned short *;
    assume ax as xsigned short;
$loop:
    if (!ecx) goto $skip;
    *edi := ax;
    edi := edi + 2;
    ecx := ecx - 1;
    goto $loop;
$skip:
    assume ecx == 0;
    updated edi;
    updated ecx;
}

pattern {
    assume DF;
    rep stosw;
} code {
    assume edi as xsigned short *;
    assume ax as xsigned short;
$loop:
    if (!ecx) goto $skip;
    *edi := ax;
    edi := edi - 2;
    ecx := ecx - 1;
    goto $loop;
$skip:
    assume ecx == 0;
    updated edi;
    updated ecx;
}

pattern {
    assume !DF;
    rep stosd;
} code {
    assume edi as xsigned long *;
    assume eax as xsigned long;
$loop:
    if (!ecx) goto $skip;
    *edi := eax;
    edi := edi + 4;
    ecx := ecx - 1;
    goto $loop;
$skip:
    assume ecx == 0;
    updated edi;
    updated ecx;
}

pattern {
    assume DF;
    rep stosd;
} code {
    assume edi as xsigned long *;
    assume eax as xsigned long;
$loop:
    if (!ecx) goto $skip;
    *edi := eax;
    edi := edi - 4;
    ecx := ecx - 1;
    goto $loop;
$skip:
    assume ecx == 0;
    updated edi;
    updated ecx;
}

// str($rm16);

pattern {
    sub $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    $1 := $1 - $2;
    ZF := $1 == 0;
    SF := $n1 < $n2;
    CF := $u1 < $u1 - $u2;
    dead OF;
    dead AF;
    dead PF;
    updated $1;
}

pattern {
    sub $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    $1 := $1 - $2;
    ZF := $1 == 0;
    SF := $n1 < $n2;
    CF := $u1 < $u1 - $u2;
    dead OF;
    dead AF;
    dead PF;
    updated $1;
}

pattern {
    sub $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    $1 := $1 - $2;
    ZF := $1 == 0;
    SF := $n1 < $n2;
    CF := $u1 < $u1 - $u2;
    dead OF;
    dead AF;
    dead PF;
    updated $1;
}

// sysenter();
// sysexit();

pattern {
    test $1, $2;
    assume sizeof($1) == 4;
} code {
    long $temp;
    $temp := ($1 & $2);
    ZF := $temp == 0;
    SF := $temp < 0;
    dead PF;
    CF := 0;
    OF := 0;
    dead AF;
}

pattern {
    test $1, $2;
    assume sizeof($1) == 2;
} code {
    short $temp;
    $temp := ($1 & $2);
    ZF := $temp == 0;
    SF := $temp < 0;
    dead PF;
    CF := 0;
    OF := 0;
    dead AF;
}

pattern {
    test $1, $2;
    assume sizeof($1) == 1;
} code {
    char $temp;
    $temp := ($1 & $2);
    ZF := $temp == 0;
    SF := $temp < 0;
    dead PF;
    CF := 0;
    OF := 0;
    dead AF;
}

// ud2();
// verr($rm16);
// verw($rm16);
// wait();
// fwait();
// wbinvd();
// wrmsr();

pattern {
    xadd $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n1;
    long $n2;
    unsigned long $u1;
    unsigned long $u2;
    xsigned long $k;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    $k := $1 + $2;
    $2 := $1;
    $1 := $k;
    ZF := $k == 0;
    SF := $n1 < $n2;
    CF := $u1 > $u1 + $u2;
    dead OF;
    dead AF;
    dead PF;
    updated $1;
    updated $2;
}

pattern {
    xadd $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n1;
    short $n2;
    unsigned short $u1;
    unsigned short $u2;
    xsigned short $k;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    $k := $1 + $2;
    $2 := $1;
    $1 := $k;
    ZF := $k == 0;
    SF := $n1 < $n2;
    CF := $u1 > $u1 + $u2;
    dead OF;
    dead AF;
    dead PF;
    updated $1;
    updated $2;
}

pattern {
    xadd $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n1;
    char $n2;
    unsigned char $u1;
    unsigned char $u2;
    xsigned char $k;
    $n1 := $1;
    $n2 := $2;
    $u1 := $1;
    $u2 := $2;
    $k := $1 + $2;
    $2 := $1;
    $1 := $k;
    ZF := $k == 0;
    SF := $n1 < $n2;
    CF := $u1 > $u1 + $u2;
    dead OF;
    dead AF;
    dead PF;
    updated $1;
    updated $2;
}

pattern {
    xchg $1, $2;
    assume sizeof($1) == 4;
} code {
    unknown_t $x;
    $x := $1;
    $1 := $2;
    $2 := $x;
    updated $1;
    updated $2;
}

pattern {
    xchg $1, $2;
    assume sizeof($1) == 2;
} code {
    xsigned short $x;
    $x := $1;
    $1 := $2;
    $2 := $x;
    updated $1;
    updated $2;
}

pattern {
    xchg $1, $2;
    assume sizeof($1) == 1;
} code {
    xsigned char $x;
    $x := $1;
    $1 := $2;
    $2 := $x;
    updated $1;
    updated $2;
}

// xgetbv();

pattern {
    xlat $1;
} code {
    assume $1 as xsigned char *;
    al := $1[al];
    updated al;
}

pattern {
    xlatb $1;
} code {
    assume $1 as xsigned char *;
    al := $1[al];
    updated al;
}

pattern {
    xor $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n;
    $1 := $1 ^ $2;
    updated $1;
    $n := $1;
    SF := $n < 0;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    dead PF;
    dead AF;
}

pattern {
    xor $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n;
    $1 := $1 ^ $2;
    updated $1;
    $n := $1;
    SF := $n < 0;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    dead PF;
    dead AF;
}

pattern {
    xor $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n;
    $1 := $1 ^ $2;
    updated $1;
    $n := $1;
    SF := $n < 0;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    dead PF;
    dead AF;
}

// xrstor($mem);
// xsave($mem);
// xsaveopt($mem);
// xsetbv();
