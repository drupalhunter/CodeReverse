////////////////////////////////////////////////////////////////////////////
// insn32.dat
// Copyright (C) 2013-2014 Katayama Hirofumi MZ.  All rights reserved.
////////////////////////////////////////////////////////////////////////////
// This file is part of CodeReverse.
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// updated

pattern {
    updated al;
} code {
    ax := (ah << 8) | al;
    eax := (eax & 0xFFFF0000) | ax;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated bl;
} code {
    bx := (bh << 8) | bl;
    ebx := (ebx & 0xFFFF0000) | bx;
}

pattern {
    updated cl;
} code {
    cx := (ch << 8) | cl;
    ecx := (ecx & 0xFFFF0000) | cx;
}

pattern {
    updated dl;
} code {
    dx := (dh << 8) | dl;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated ah;
} code {
    ax := (ah << 8) | al;
    eax := (eax & 0xFFFF0000) | ax;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated bh;
} code {
    bx := (bh << 8) | bl;
    ebx := (ebx & 0xFFFF0000) | bx;
}

pattern {
    updated ch;
} code {
    cx := (ch << 8) | cl;
    ecx := (ecx & 0xFFFF0000) | cx;
}

pattern {
    updated dh;
} code {
    dx := (dh << 8) | dl;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated ax;
} code {
    al := ax & 0xFF;
    eax := (eax & 0xFFFF0000) | ax;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated bx;
} code {
    bl := bx & 0xFF;
    ebx := (ebx & 0xFFFF0000) | bx;
}

pattern {
    updated cx;
} code {
    cl := cx & 0xFF;
    ecx := (ecx & 0xFFFF0000) | cx;
}

pattern {
    updated dx;
} code {
    dl := dx & 0xFF;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated sp;
} code {
    esp := (esp & 0xFFFF0000) | sp;
}

pattern {
    updated bp;
} code {
    ebp := (ebp & 0xFFFF0000) | bp;
}

pattern {
    updated si;
} code {
    esi := (esi & 0xFFFF0000) | si;
}

pattern {
    updated di;
} code {
    edi := (edi & 0xFFFF0000) | di;
}

pattern {
    updated eax;
} code {
    al := eax & 0xFF;
    ah := (eax >>> 8) & 0xFF;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated ebx;
} code {
    bl := ebx & 0xFF;
    bh := (ebx >>> 8) & 0xFF;
}

pattern {
    updated ecx;
} code {
    cl := ecx & 0xFF;
    ch := (ecx >>> 8) & 0xFF;
}

pattern {
    updated edx;
} code {
    dl := edx & 0xFF;
    dh := (edx >>> 8) & 0xFF;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated esp;
} code {
    sp := esp & 0xFFFF;
}

pattern {
    updated ebp;
} code {
    bp := ebp & 0xFFFF;
}

pattern {
    updated esi;
} code {
    si := esi & 0xFFFF;
}

pattern {
    updated edi;
} code {
    di := edi & 0xFFFF;
}

pattern {
    updated al, ah;
} code {
    ax := (ah << 8) | al;
    eax := (eax & 0xFFFF0000) | ax;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

pattern {
    updated bl, bh;
} code {
    bx := (bh << 8) | bl;
    ebx := (ebx & 0xFFFF0000) | bx;
}

pattern {
    updated cl, ch;
} code {
    cx := (ch << 8) | cl;
    ecx := (ecx & 0xFFFF0000) | cx;
}

pattern {
    updated dl, dh;
} code {
    dx := (dh << 8) | dl;
    edx := (edx & 0xFFFF0000) | dx;
    dx:ax := (cast<long>(dx) << 32) | ax;
    edx:eax := (cast<long long>(edx) << 32) | eax;
}

////////////////////////////////////////////////////////////////////////////
// technical

pattern {
    asm push $1;
    asm pop $2;
} code {
    $2 := $1;
    updated $2;
}

pattern {
    asm push $1;
    asm push $2;
    asm pop $3;
    asm pop $4;
} code {
    $3 := $2;
    $4 := $1;
    updated $3;
    updated $4;
}

pattern {
    asm push $1;
    asm push $2;
    asm push $3;
    asm pop $4;
    asm pop $5;
    asm pop $6;
} code {
    $4 := $3;
    $5 := $2;
    $6 := $1;
    updated $4;
    updated $5;
    updated $6;
}

pattern {
    asm push $1;
    asm push $2;
    asm push $3;
    asm push $4;
    asm pop $5;
    asm pop $6;
    asm pop $7;
    asm pop $8;
} code {
    $5 := $4;
    $6 := $3;
    $7 := $2;
    $8 := $1;
    updated $5;
    updated $6;
    updated $7;
    updated $8;
}

pattern {
    assume eax == 0;
    assume ecx == 0xFFFFFFFF;
    asm repne scasb;
    asm not ecx;
    asm lea $0,[ecx-1];
} code {
    assume $0 as size_t;
    $0 := strlen(edi);
    update $0;
}

pattern {
    asm cdq;
    asm xor eax,edx;
    asm sub eax,edx;
} code {
    eax := abs(eax);
    dl dead;
    dh dead;
    dx dead;
    edx dead;
    updated eax;
}

////////////////////////////////////////////////////////////////////////////
// instructions

pattern {
    asm aaa;
} code {
    if ((al & 0x0F) >= 10 || AF) goto $skip;
    AF := 0;
    CF := 0;
    goto $join;
$skip:
    al := al + 6;
    ah := ah + 1;
    AF := 1;
    CF := 1;
$join:
    al := al & 0x0F;
    updated al, ah;
    OF dead;
    SF dead;
    ZF dead;
    PF dead;
}

pattern {
    asm aad;
} code {
    al := al + ah * 10;
    ZF := al == 0;
    SF := al < 0;
    ah := 0;
    updated al, ah;
    OF dead;
    AF dead;
    PF dead;
    CF dead;
}

pattern {
    asm aam, $1;
} code {
    ah := al / $1;
    al := al % $1;
    ZF := al == 0;
    SF := al < 0;
    updated al, ah;
    OF dead;
    AF dead;
    PF dead;
    CF dead;
}

pattern {
    asm aas;
} code {
    if ((al & 0F) >= 10 || AF) goto $skip;
    AF := 0;
    CF := 0;
    goto $join;
$skip:
    al := al - 6;
    ah := ah - 1;
    AF := 1;
    CF := 1;
$join:
    al := al & 0x0F;
    OF dead;
    SF dead;
    ZF dead;
    PF dead;
    SFeqOF dead;
}

pattern {
    asm adc $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n1 := $1;
    long $n2 := $2 + CF;
    unsigned long $m1 := $1
    unsigned long $m2 := $2 + CF;
    $1 := $1 + $2 + CF;
    long $n3 := $1;
    unsigned long $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $n3 == 0;
    SF := $n3 < 0;
    CF := ($m1 > $m3 - CF) || ($m1 > $m3);
    AF dead;
    PF dead;
}

pattern {
    asm adc $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n1 := $1;
    short $n2 := $2 + CF;
    unsigned short $m1 := $1
    unsigned short $m2 := $2 + CF;
    $1 := $1 + $2 + CF;
    short $n3 := $1;
    unsigned short $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $n3 == 0;
    SF := $n3 < 0;
    CF := ($m1 > $m3 - CF) || ($m1 > $m3);
    AF dead;
    PF dead;
}

pattern {
    asm adc $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n1 := $1;
    char $n2 := $2 + CF;
    unsigned char $m1 := $1
    unsigned char $m2 := $2 + CF;
    $1 := $1 + $2 + CF;
    char $n3 := $1;
    unsigned char $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $n3 == 0;
    SF := $n3 < 0;
    CF := ($m1 > $m3 - CF) || ($m1 > $m3);
    AF dead;
    PF dead;
}

pattern {
    asm add $1, $2;
    assume sizeof($1) == 4;
} code {
    long $n1 := $1;
    long $n2 := $2;
    unsigned long $m1 := $1;
    unsigned long $m2 := $2;
    $1 := $1 + $2;
    long $n3 := $1;
    unsigned long $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $n3 == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    AF dead;
    PF dead;
}

pattern {
    asm add $1, $2;
    assume sizeof($1) == 2;
} code {
    short $n1 := $1;
    short $n2 := $2;
    unsigned short $m1 := $1;
    unsigned short $m2 := $2;
    $1 := $1 + $2;
    short $n3 := $1;
    unsigned short $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $n3 == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    AF dead;
    PF dead;
}

pattern {
    asm add $1, $2;
    assume sizeof($1) == 1;
} code {
    char $n1 := $1;
    char $n2 := $2;
    unsigned char $m1 := $1;
    unsigned char $m2 := $2;
    $1 := $1 + $2;
    char $n3 := $1;
    unsigned char $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $n3 == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    AF dead;
    PF dead;
}

pattern {
    asm and $1, $1;
    assume sizeof($1) == 4;
} code {
    long $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    AF dead;
    PF dead;
}

pattern {
    asm and $1, $1;
    assume sizeof($1) == 2;
} code {
    short $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    AF dead;
    PF dead;
}

pattern {
    asm and $1, $1;
    assume sizeof($1) == 1;
} code {
    char $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    AF dead;
    PF dead;
}

pattern {
    asm and $1, $2;
    assume sizeof($1) == 4;
} code {
    $1 := $1 & $2;
    long $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    AF dead;
    PF dead;
}

pattern {
    asm and $1, $2;
    assume sizeof($1) == 2;
} code {
    $1 := $1 & $2;
    short $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    AF dead;
    PF dead;
}

pattern {
    asm and $1, $2;
    assume sizeof($1) == 1;
} code {
    $1 := $1 & $2;
    char $n := $1;
    ZF := $n == 0;
    SF := $n < 0;
    CF := 0;
    OF := 0;
    AF dead;
    PF dead;
}

// INSN arpl($dest, $src);
// INSN bound($dest,$src);

pattern {
    asm bsf $1, $2;
    assume sizeof($1) == 4;
} code {
    if ($2 == 0) goto $error;
    ZF := 0;
    long $temp := 0;
$loop:
    if (($1 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp + 1;
    goto $loop;
$skip:
    $2 := $temp;
    goto $end;
$error:
    ZF := 1;
    $2 dead;
$end:
    CF dead;
    OF dead;
    SF dead;
    AF dead;
    PF dead;
}

pattern {
    asm bsf $1, $2;
    assume sizeof($1) == 2;
} code {
    if ($2 == 0) goto $error;
    ZF := 0;
    short $temp := 0;
$loop:
    if (($1 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp + 1;
    goto $loop;
$skip:
    $2 := $temp;
    goto $end;
$error:
    ZF := 1;
    $2 dead;
$end:
    CF dead;
    OF dead;
    SF dead;
    AF dead;
    PF dead;
}

pattern {
    asm bsr $1, $2;
    assume sizeof($1) == 4;
} code {
    if ($2 == 0) goto $error;
    ZF := 0;
    long $temp := 31;
$loop:
    if (($2 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp - 1;
    goto $loop;
$skip:
    goto $end;
$error:
    ZF := 1;
    $1 dead;
$end:
    CF dead;
    OF dead;
    SF dead;
    AF dead;
    PF dead;
}

pattern {
    asm bsr $1, $2;
    assume sizeof($1) == 2;
} code {
    if ($2 == 0) goto $error;
    ZF := 0;
    short $temp := 15;
$loop:
    if (($2 & (1 << $temp)) == 0) goto $skip;
    $temp := $temp - 1;
    goto $loop;
$skip:
    goto $end;
$error:
    ZF := 1;
    $1 dead;
$end:
    CF dead;
    OF dead;
    SF dead;
    AF dead;
    PF dead;
}

pattern {
    asm bswap $1;
    assume sizeof($1) == 4;
} code {
    $1 := _bswap($1);
}

pattern {
    asm bt $1, $2;
} code {
    CF := ($1 & (1 << $2)) != 0;
    OF dead;
    SF dead;
    AF dead;
    PF dead;
}

pattern {
    asm btc $1, $2;
} code {
    CF := ($1 & (1 << $2)) != 0;
    if (CF) goto $reset;
    $1 := $1 | (1 << $2);
    goto $join;
$reset:
    $1 := $1 & ~(1 << $2);
$join:
    OF dead;
    SF dead;
    AF dead;
    PF dead;
}

pattern {
    asm btr $1, $2;
} code {
    CF := ($1 & (1 << $2)) != 0;
    $1 := $1 & ~(1 << $2);
    OF dead;
    SF dead;
    AF dead;
    PF dead;
}

pattern {
    asm bts $1, $2;
} code {
    CF := ($1 & (1 << $2)) != 0;
    $1 := $1 | (1 << $2);
    OF dead;
    SF dead;
    AF dead;
    PF dead;
}

// asm call $1;

pattern {
    asm cbw;
} code {
    assume al as char;
    ax := al;
    assume ax as short;
    updated ax;
}

pattern {
    asm cwde;
} code {
    assume ax as short;
    eax := ax;
    assume eax as int;
    updated eax;
}

pattern {
    asm clc
} code {
    CF := 0;
}

pattern {
    asm cld;
} code {
    DF := 0;
}

// INSN clflush($m8);

pattern {
    asm cli;
} code {
    IF := 0;
}

// INSN clts();

pattern {
    asm cmc;
} code {
    CF := !CF;
}

pattern {
    asm cmova $1, $2;
} code {
    if (CF || ZF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovae $1, $2;
} code {
    if (CF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovb $1, $2;
} code {
    if (!CF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovbe $1, $2;
} code {
    if (!CF && !ZF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovc $1, $2;
} code {
    if (!CF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmove $1, $2;
} code {
    if (!ZF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovg $1, $2;
} code {
    if (ZF || SF != OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovge $1, $2;
} code {
    if (SF != OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovl $1, $2;
} code {
    if (SF == OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovle $1, $2;
} code {
    if (!ZF && SF == OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovna $1, $2;
} code {
    if (!CF && !ZF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnae $1, $2;
} code {
    if (!CF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnb $1, $2;
} code {
    if (CF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnbe $1, $2;
} code {
    if (CF || ZF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnc $1, $2;
} code {
    if (CF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovne $1, $2;
} code {
    if (ZF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovng $1, $2;
} code {
    if (!ZF && SF == OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnge $1, $2;
} code {
    if (SF == OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnl $1, $2;
} code {
    if (SF != OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnle $1, $2;
} code {
    if (ZF || SF != OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovno $1, $2;
} code {
    if (OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnp $1, $2;
} code {
    if (PF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovns $1, $2;
} code {
    if (SF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovnz $1, $2;
} code {
    if (ZF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovo $1, $2;
} code {
    if (!OF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovp $1, $2;
} code {
    if (!PF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovpe $1, $2;
} code {
    if (!PF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovpo $1, $2;
} code {
    if (PF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovs $1, $2;
} code {
    if (!SF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmovz $1, $2;
} code {
    if (!ZF) goto $skip;
    $1 := $2;
$skip:
}

pattern {
    asm cmp $1, $2;
    assume sizeof($1) == 4;
} code {
    long $s1 := $1;
    long $s2 := $1 - $2;
    unsigned long $u1 := $1;
    unsigned long $u2 := $1 - $2;
    ZF := $1 == 0;
    SF := $s2 < 0;
    OF dead;
    CF := $u1 < $u2;
    AF dead;
    PF dead;
}

pattern {
    asm cmp $1, $2;
    assume sizeof($1) == 2;
} code {
    short $s1 := $1;
    short $s2 := $1 - $2;
    unsigned short $u1 := $1;
    unsigned short $u2 := $1 - $2;
    ZF := $1 == 0;
    SF := $s2 < 0;
    OF dead;
    CF := $u1 < $u2;
    AF dead;
    PF dead;
}

pattern {
    asm cmp $1, $2;
    assume sizeof($1) == 1;
} code {
    char $s1 := $1;
    char $s2 := $1 - $2;
    unsigned char $u1 := $1;
    unsigned char $u2 := $1 - $2;
    ZF := $1 == 0;
    SF := $s2 < 0;
    OF dead;
    CF := $u1 < $u2;
    AF dead;
    PF dead;
}

pattern {
    assume !DF;
    asm cmpsb;
} code {
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    xsigned char $temp := *esi - *edi;
    SetStatusFlags $temp;
    esi := esi + 1;
    edi := edi + 1;
}

pattern {
    assume DF;
    asm cmpsb;
} code {
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    xsigned char $temp := *esi - *edi;
    SetStatusFlags $temp;
    esi := esi - 1;
    edi := edi - 1;
}

pattern {
    assume !DF;
    asm cmpsw;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    xsigned char $temp := *esi - *edi;
    SetStatusFlags $temp;
    esi := esi + 1;
    edi := edi + 1;
}

pattern {
    assume DF;
    asm cmpsw;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    xsigned char $temp := *esi - *edi;
    SetStatusFlags $temp;
    esi := esi - 1;
    edi := edi - 1;
}

pattern {
    assume !DF;
    asm cmpsd;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    xsigned char $temp := *esi - *edi;
    SetStatusFlags $temp;
    esi := esi + 1;
    edi := edi + 1;
}

pattern {
    assume DF;
    asm cmpsd;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    xsigned char $temp := *esi - *edi;
    SetStatusFlags $temp;
    esi := esi - 1;
    edi := edi - 1;
}

pattern {
    assume !DF;
    asm repe cmpsb;
} code {
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    assume ecx as unsigned int;
    int $minus;
    xsigned char $n;
$loop:
    $minus := cast<char>(*esi) < 0;
    OF := $minus && cast<char>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi + 1;
    edi := edi + 1;
    ecx := ecx - 1;
    if (ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume DF;
    asm repe cmpsb;
} code {
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    assume ecx as unsigned int;
    int $minus;
    xsigned char $n;
$loop:
    $minus := cast<char>(*esi) < 0;
    OF := $minus && cast<char>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi - 1;
    edi := edi - 1;
    ecx := ecx - 1;
    if (ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume !DF;
    asm repe cmpsw;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned int;
    int $minus;
    xsigned short $n;
$loop:
    $minus := cast<short>(*esi) < 0;
    OF := $minus && cast<short>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi + 1;
    edi := edi + 1;
    ecx := ecx - 1;
    if (ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume DF;
    asm repe cmpsw;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned int;
    int $minus;
    xsigned short $n;
$loop:
    $minus := cast<short>(*esi) < 0;
    OF := $minus && cast<short>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi - 1;
    edi := edi - 1;
    ecx := ecx - 1;
    if (ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume !DF;
    asm repe cmpsd;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned int;
    int $minus;
    xsigned long $n;
$loop:
    $minus := cast<long>(*esi) < 0;
    OF := $minus && cast<long>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi + 1;
    edi := edi + 1;
    ecx := ecx - 1;
    if (ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume DF;
    asm repe cmpsd;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned int;
    int $minus;
    xsigned long $n;
$loop:
    $minus := cast<long>(*esi) < 0;
    OF := $minus && cast<long>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi - 1;
    edi := edi - 1;
    ecx := ecx - 1;
    if (ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}


alias repz cmpsb := repe cmpsb;
alias repz cmpsw := repe cmpsw;
alias repz cmpsd := repe cmpsd;

pattern {
    assume !DF;
    asm repne cmpsb;
} code {
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    assume ecx as unsigned int;
    int $minus;
    xsigned char $n;
$loop:
    $minus := cast<char>(*esi) < 0;
    OF := $minus && cast<char>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi + 1;
    edi := edi + 1;
    ecx := ecx - 1;
    if (!ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume DF;
    asm repne cmpsb;
} code {
    assume edi as xsigned char *;
    assume esi as xsigned char *;
    assume ecx as unsigned int;
    int $minus;
    xsigned char $n;
$loop:
    $minus := cast<char>(*esi) < 0;
    OF := $minus && cast<char>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi - 1;
    edi := edi - 1;
    ecx := ecx - 1;
    if (!ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume !DF;
    asm repne cmpsw;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned int;
    int $minus;
    xsigned short $n;
$loop:
    $minus := cast<short>(*esi) < 0;
    OF := $minus && cast<short>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi + 1;
    edi := edi + 1;
    ecx := ecx - 1;
    if (!ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume DF;
    asm repne cmpsw;
} code {
    assume edi as xsigned short *;
    assume esi as xsigned short *;
    assume ecx as unsigned int;
    int $minus;
    xsigned short $n;
$loop:
    $minus := cast<short>(*esi) < 0;
    OF := $minus && cast<short>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi - 1;
    edi := edi - 1;
    ecx := ecx - 1;
    if (!ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume !DF;
    asm repne cmpsd;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned int;
    int $minus;
    xsigned long $n;
$loop:
    $minus := cast<long>(*esi) < 0;
    OF := $minus && cast<long>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi + 1;
    edi := edi + 1;
    ecx := ecx - 1;
    if (!ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

pattern {
    assume DF;
    asm repne cmpsd;
} code {
    assume edi as xsigned long *;
    assume esi as xsigned long *;
    assume ecx as unsigned int;
    int $minus;
    xsigned long $n;
$loop:
    $minus := cast<long>(*esi) < 0;
    OF := $minus && cast<long>(*edi) > 0;
    $n := *esi - *edi;
    ZF := $n == 0;
    esi := esi - 1;
    edi := edi - 1;
    ecx := ecx - 1;
    if (!ZF) goto $loop;
    SF := $n < 0;
    CF := $minus && $n >= 0;
    AF dead;
    PF dead;
}

alias repnz cmpsb := repne cmpsb;
alias repnz cmpsw := repne cmpsw;
alias repnz cmpsd := repne cmpsd;

pattern {
    asm cmpxchg al, $1
} code {
    al := $1;
    updated al;
    ZF := 1;
    SF := cast<char>(al) < 0;
    CF dead;
    PF dead;
    AF dead;
}

pattern {
    asm cmpxchg ax, $1
} code {
    ax := $1;
    updated ax;
    ZF := 1;
    SF := cast<short>(ax) < 0;
    CF dead;
    PF dead;
    AF dead;
}

pattern {
    asm cmpxchg eax, $1
} code {
    eax := $1;
    updated eax;
    ZF := 1;
    SF := cast<long>(eax) < 0;
    CF dead;
    PF dead;
    AF dead;
}

pattern {
    asm cmpxchg $1, $2
    assume sizeof($1) == 4;
} code {
    eax := $2;
    ZF := 0;
    SF := cast<long>(eax) < 0;
    CF dead;
    PF dead;
    AF dead;
}

pattern {
    asm cmpxchg $1, $2
    assume sizeof($1) == 2;
} code {
    ax := $2;
    ZF := 0;
    SF := cast<short>(ax) < 0;
    CF dead;
    PF dead;
    AF dead;
}

pattern {
    asm cmpxchg $1, $2
    assume sizeof($1) == 1;
} code {
    al := $2;
    ZF := 0;
    SF := cast<char>(al) < 0;
    CF dead;
    PF dead;
    AF dead;
}



...

// INSN cmpxchg8b(void *$m64);
// INSN cmpxchg16b(void *$m128);
// INSN cpuid();
// INSN crc32($dest, $src);

pattern {
    asm cwd;
} code {
    assume ax as short;
    dx:ax = ax;
    assume dx:ax as long;
    updated dx;
}

pattern {
    asm cdq;
} code {
    assume eax as long;
    edx:eax = eax;
    assume edx:eax as long long;
    updated edx;
}

INSN daa()
    register UCHAR al := al;
    UCHAR $oldal := al;
    BOOL $oldcf := CF;
    if ((al & 0x0F) >= 10 && AF) {
        al += 6;
        CF dead;
        AF := 1;
    } else {
        CF := 0;
        AF := 0;
    }
    if ($oldal > 0x99 || $oldcf) {
        al += 0x60;
        CF := 1;
    } else {
        CF := 0;
    }
    OF dead;
    SF := al > 0;
    ZF := al == 0;
    PF dead;
    SFeqOF dead;
END INSN

INSN das()
    register UCHAR al := al;
    UCHAR $oldal := al;
    BOOL $oldcf := CF;
    if ((al & 0x0F) >= 10 && AF) {
        al -= 6;
        CF dead;
        AF := 1;
    } else {
        CF := 0;
        AF := 0;
    }
    if ($oldal > 0x99 && $oldcf) {
        al -= 0x60;
        CF := 1;
    }
    OF dead;
    SF := al < 0;
    ZF := al == 0;
    PF dead;
    SFeqOF dead;
END INSN

pattern {
    asm dec $1;
    assume sizeof($1) == 4;
} code {
    $1 := $1 - 1;
    long $v = $1;
    OF dead;
    SF := $v < 0;
    ZF := $v == 0;
    AF dead;
    PF dead;
}

pattern {
    asm dec $1;
    assume sizeof($1) == 2;
} code {
    $1 := $1 - 1;
    short $v = $1;
    OF dead;
    SF := $v < 0;
    ZF := $v == 0;
    AF dead;
    PF dead;
}

pattern {
    asm dec $1;
    assume sizeof($1) == 1;
} code {
    $1 := $1 - 1;
    char $v = $1;
    OF dead;
    SF := $v < 0;
    ZF := $v == 0;
    AF dead;
    PF dead;
}

pattern {
    asm div $1;
    assume sizeof($1) == 4;
} code {
    assume edx:eax as unsigned long long;
    eax := edx:eax / $1;
    edx := edx:eax % $1;
    updated eax, edx;
    CF dead;
    OF dead;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}

pattern {
    asm div $1;
    assume sizeof($1) == 2;
} code {
    assume dx:ax as unsigned long;
    ax := dx:ax / $1;
    dx := dx:ax % $1;
    updated ax, dx;
    CF dead;
    OF dead;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}


pattern {
    asm div $1;
    assume sizeof($1) == 1;
} code {
    assume ax as unsigned short;
    al := ax / $1;
    ah := ax % $1;
    updated al, ah;
    CF dead;
    OF dead;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}

// INSN enter(WORD $a, UCHAR $b);
// INSN hlt();

pattern {
    asm idiv $1;
    assume sizeof($1) == 4;
} code {
    assume edx:eax as long long;
    eax := edx:eax / $1;
    edx := edx:eax % $1;
    assume eax as long;
    assume edx as long;
    updated eax, edx;
    CF dead;
    OF dead;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}

pattern {
    asm idiv $1;
    assume sizeof($1) == 2;
} code {
    assume dx:ax as long;
    ax := dx:ax / $1;
    dx := dx:ax % $1;
    assume ax as short;
    assume dx as short;
    updated ax, dx;
    CF dead;
    OF dead;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}

pattern {
    asm idiv $1;
    assume sizeof($1) == 1;
} code {
    assume ax as short;
    al := ax / $1;
    ah := ax % $1;
    assume al as char;
    assume ah as char;
    updated al, ah;
    CF dead;
    OF dead;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}

pattern {
    asm imul $1;
    assume sizeof($1) == 4;
} code {
    assume eax as long;
    assume edx:eax as long long;
    edx:eax := eax * $1;
    CF := eax != edx:eax;
    OF := eax != edx:eax;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}

pattern {
    asm imul $1;
    assume sizeof($1) == 2;
} code {
    assume ax as short;
    assume dx:ax as long;
    dx:ax := ax * $1;
    CF := ax != dx:ax;
    OF := ax != dx:ax;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}

pattern {
    asm imul $1;
    assume sizeof($1) == 1;
} code {
    assume al as short;
    assume ax as long;
    ax := al * $1;
    CF := al != ax;
    OF := al != ax;
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
}

INSN imul($dest, SIGNED $src)
    if (sizeof($dest) == 1) {
        SHORT $temp($dest);
        $temp *= $src;
        $dest *= $src;
        CF := $temp != $dest;
        OF := $temp != $dest;
    } else if (sizeof($dest) == 2) {
        LONG $temp($dest);
        $temp *= $src;
        $dest *= $src;
        CF := $temp != $dest;
        OF := $temp != $dest;
    } else if (sizeof($dest) == 4) {
        LONGLONG $temp($dest);
        $temp *= $src;
        $dest *= $src;
        CF := $temp != $dest;
        OF := $temp != $dest;
    }
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
    SFeqOF dead;
END INSN

INSN imul($dest, SIGNED $src1, SIGNED $src2)
    if (sizeof($src1) == 1) {
        SHORT $temp($src1);
        $temp *= $src2;
        $dest := $src1 * $src2;
        CF := $temp != $dest;
        OF := $temp != $dest;
    } else if (sizeof($src) == 2) {
        LONG $temp($src1);
        $temp *= $src2;
        $dest := $src1 * $src2;
        CF := $temp != $dest;
        OF := $temp != $dest;
    } else if (sizeof($src) == 4) {
        LONGLONG $temp($src1);
        $temp *= $src2;
        $dest := $src1 * $src2;
        CF := $temp != $dest;
        OF := $temp != $dest;
    }
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
    SFeqOF dead;
END INSN

// INSN in($dest, $src);

INSN inc($dest)
    $dest += 1;
    SIGNED typeof($dest) $v := $dest;
    OF dead;
    SF := $v < 0;
    ZF := $dest == 0;
    AF dead;
    PF dead;
    SFeqOF := $v >= 0;
END INSN

// INSN insb();
// INSN insw();
// INSN insd();
// INSN int3();
// INSN int($a);
// INSN into();
// INSN invd();
// INSN invlpg($m);
// INSN invpcid($dest, $src);
// INSN iret();
// INSN iretd();

pattern {
    asm ja $1;
} code {
    if (!ZF && !CF) goto $1;
}

pattern {
    asm jae $1;
} code {
    if (!CF) goto $1;
}

pattern {
    asm jb $1;
} code {
    if (CF) goto $1;
}

pattern {
    asm jbe $1;
} code {
    if (ZF || CF) goto $1;
}

pattern {
    asm jc $1;
} code {
    if (CF) goto $1;
}

pattern {
    asm jcxz $1;
} code {
    if (cx == 0) goto $1;
}

pattern {
    asm jecxz $1;
} code {
    if (ecx == 0) goto $1;
}

pattern {
    asm je $1;
} code {
    if (ZF) goto $1;
}

pattern {
    asm jg $1;
} code {
    if (!ZF && SF == OF) goto $1;
}

pattern {
    asm jge $1;
} code {
    if (SF == OF) goto $1;
}

pattern {
    asm jl $1;
} code {
    if (SF != OF) goto $1;
}

pattern {
    asm jle $1;
} code {
    if (ZF && SF != OF) goto $1;
}

pattern {
    asm jmp $1;
} code {
    goto $1;
}

pattern {
    asm jna $1;
} code {
    if (ZF || CF) goto $1;
}

pattern {
    asm jnae $1;
} code {
    if (CF) goto $1;
}

pattern {
    asm jnb $1;
} code {
    if (!CF) goto $1;
}

pattern {
    asm jnb $e1;
} code {
    if (!ZF && !CF) goto $1;
}

pattern {
    asm jnc $e1;
} code {
    if (!CF) goto $1;
}

pattern {
    asm jne $e1;
} code {
    if (!ZF) goto $1;
}

pattern {
    asm jng $e1;
} code {
    if (ZF || SF != OF) goto $1;
}

pattern {
    asm jnge $e1;
} code {
    if (SF != OF) goto $1;
}

pattern {
    asm jnl $e1;
} code {
    if (SF == OF) goto $1;
}

pattern {
    asm jnle $e1;
} code {
    if (!ZF && SF == OF) goto $1;
}

pattern {
    asm jno $e1;
} code {
    if (!OF) goto $1;
}

pattern {
    asm jnp $e1;
} code {
    if (!PF) goto $1;
}

pattern {
    asm jns $e1;
} code {
    if (!SF) goto $1;
}

pattern {
    asm jnz $e1;
} code {
    if (!ZF) goto $1;
}

pattern {
    asm jo $e1;
} code {
    if (OF) goto $1;
}

pattern {
    asm jp $e1;
} code {
    if (PF) goto $1;
}

pattern {
    asm jpe $e1;
} code {
    if (PF) goto $1;
}

pattern {
    asm jpo $e1;
} code {
    if (!PF) goto $1;
}

pattern {
    asm js $e1;
} code {
    if (SF) goto $1;
}

pattern {
    asm jz $e1;
} code {
    if (ZF) goto $1;
}

// INSN lahf();
// INSN lar($dest, $src);
// INSN lds(void *$dest, void *$src);
// INSN les(void *$dest, void *$src);
// INSN lfs(void *$dest, void *$src);
// INSN lgs(void *$dest, void *$src);

pattern {
    asm lea $1, $2;
} code {
    $1 := &$2;
}

// INSN leave();
// INSN lfence();
// INSN lgdt($m1632);
// INSN lidt($m1632);
// INSN lldt($src);
// INSN lmsw($src);
// INSN lock();

pattern {
    asm lodsb;
    assume !DF;
} code {
    assume esi as xsigned char *;
    assume al as xsigned char;
    al := *esi;
    esi := esi + 1;
}

pattern {
    asm lodsb;
    assume !DF;
} code {
    assume esi as xsigned char *;
    assume al as xsigned char;
    al := *esi;
    esi := esi - 1;
}

pattern {
    asm lodsw;
    assume !DF;
} code {
    assume esi as xsigned short *;
    assume ax as xsigned short;
    ax := *esi;
    esi := esi + 1;
}

pattern {
    asm lodsw;
    assume !DF;
} code {
    assume esi as xsigned short *;
    assume ax as xsigned short;
    ax := *esi;
    esi := esi - 1;
}

pattern {
    asm lodsd;
    assume !DF;
} code {
    assume esi as xsigned long *;
    assume eax as xsigned long;
    eax := *esi;
    esi := esi + 1;
}

pattern {
    asm lodsd;
    assume !DF;
} code {
    assume esi as xsigned long *;
    assume eax as xsigned long;
    eax := *esi;
    esi := esi - 1;
}

INSN rep lodsb()
    register XCHAR *esi := esi;
    register XCHAR al := al;
    register ULONG ecx := ecx;
    if (DF) {
        while (ecx) {
            al := *esi;
            esi -= 1;
            ecx -= 1;
        }
    } else {
        while (ecx) {
            al := *esi;
            esi += 1;
            ecx -= 1;
        }
    }
END INSN

INSN rep lodsw()
    register XSHORT *esi := esi;
    register XSHORT ax := ax;
    register ULONG ecx := ecx;
    if (DF) {
        while (ecx) {
            ax := *esi;
            esi -= 1;
            ecx -= 1;
        }
    } else {
        while (ecx) {
            ax := *esi;
            esi += 1;
            ecx -= 1;
        }
    }
END INSN

INSN rep lodsd()
    register XLONG *esi := esi;
    register XLONG eax := eax;
    register ULONG ecx := ecx;
    if (DF) {
        while (ecx) {
            eax := *esi;
            esi -= 1;
            ecx -= 1;
        }
    } else {
        while (ecx) {
            eax := *esi;
            esi += 1;
            ecx -= 1;
        }
    }
END INSN

INSN loop($dest)
    register ULONG ecx := ecx;
    ecx -= 1;
    if (ecx) {
        goto $dest;
    }
END INSN

INSN loope($dest)
    register ULONG ecx := ecx;
    ecx -= 1;
    if (ZF && ecx) {
        goto $dest;
    }
END INSN

INSN loopne($dest)
    register ULONG ecx := ecx;
    ecx -= 1;
    if (!ZF && ecx) {
        goto $dest;
    }
END INSN

INSN loopnz($dest)
    register ULONG ecx := ecx;
    ecx -= 1;
    if (!ZF && ecx) {
        goto $dest;
    }
END INSN

INSN loopz($dest)
    register ULONG ecx := ecx;
    ecx -= 1;
    if (ZF && ecx) {
        goto $dest;
    }
END INSN

// INSN lsl($dest, $src);
// INSN ltr($src);
// INSN mfence();
// INSN monitor();

INSN mov($dest, $src)
    $dest := $src;
END INSN

// INSN movbe(XSIGNED $dest, UNSIGNED $src); // TODO:
// INSN movnti($dest, $src);

INSN movsb()
    register XCHAR *edi := edi;
    register XCHAR *esi := esi;
    *edi := *esi;
    if (DF) {
        edi -= 1;
        esi -= 1;
    } else {
        edi += 1;
        esi += 1;
    }
END INSN

INSN movsw()
    register XSHORT *edi := edi;
    register XSHORT *esi := esi;
    *edi := *esi;
    if (DF) {
        edi -= 1;
        esi -= 1;
    } else {
        edi += 1;
        esi += 1;
    }
END INSN

INSN movsd()
    register XLONG *edi := edi;
    register XLONG *esi := esi;
    *edi := *esi;
    if (DF) {
        edi -= 1;
        esi -= 1;
    } else {
        edi += 1;
        esi += 1;
    }
END INSN

INSN rep movsb()
    register XCHAR *edi := edi;
    register XCHAR *esi := esi;
    register ULONG ecx := ecx;
    if (DF) {
        while (ecx) {
            *edi := *esi;
            edi -= 1;
            esi -= 1;
            ecx -= 1;
        }
    } else {
        while (ecx) {
            *edi := *esi;
            edi += 1;
            esi += 1;
            ecx -= 1;
        }
    }
END INSN

INSN rep movsw()
    register XSHORT *edi := edi;
    register XSHORT *esi := esi;
    register ULONG ecx := ecx;
    if (DF) {
        while (ecx) {
            *edi := *esi;
            edi -= 1;
            esi -= 1;
            ecx -= 1;
        }
    } else {
        while (ecx) {
            *edi := *esi;
            edi += 1;
            esi += 1;
            ecx -= 1;
        }
    }
END INSN

INSN rep movsd()
    register XLONG *edi := edi;
    register XLONG *esi := esi;
    register ULONG ecx := ecx;
    if (DF) {
        while (ecx) {
            *edi := *esi;
            edi -= 1;
            esi -= 1;
            ecx -= 1;
        }
    } else {
        while (ecx) {
            *edi := *esi;
            edi += 1;
            esi += 1;
            ecx -= 1;
        }
    }
END INSN

INSN movsx($dest, SIGNED $src)
    if (sizeof($dest) == 2) {
        SHORT $v := $src;
        $dest := $v;
    } else if (sizeof($dest) == 4) {
        LONG $v := $src;
        $dest := $v;
    }
END INSN

INSN movzx($dest, UNSIGNED $src)
    if (sizeof($dest) == 2) {
        WORD $v := $src;
        $dest := $v;
    } else if (sizeof($dest) == 4) {
        ULONG $v := $src;
        $dest := $v;
    }
END INSN

INSN mul(UNSIGNED $src)
    if (sizeof($src) == 1) {
        WORD $v := al;
        ax := $v * $src;
        register UCHAR al := al;
        register UCHAR ah := ah;
        register WORD ax := ax;
        OF := ax != al;
        CF := ax != al;
    } else if (sizeof($src) == 2) {
        ULONG $v := ax;
        dx:ax := $v * $src;
        register WORD ax := ax;
        register WORD dx := dx;
        register ULONG dx:ax := dx:ax;
        OF := dx:ax != ax;
        CF := dx:ax != ax;
    } else if (sizeof($src) == 4) {
        ULONGLONG $v := eax;
        edx:eax := $v * $src;
        register ULONG eax := eax;
        register ULONG edx := edx;
        register ULONGLONG edx:eax := edx:eax;
        OF := edx:eax != eax;
        CF := edx:eax != eax;
    }
    SF dead;
    ZF dead;
    AF dead;
    PF dead;
    SFeqOF dead;
END INSN

// INSN mwait();

INSN neg(SIGNED $dest)
    $dest := -$dest;
    CF := $dest != 0;
    OF := 0;
    SF := $dest < 0;
    ZF := $dest == 0;
    AF dead;
    PF dead;
    SFeqOF := $dest >= 0;
END INSN

INSN nop()
END INSN

INSN nop($src)
END INSN

pattern {
    asm not $1;
} code {
    $1 = ~$1;
}

pattern {
    asm or $1, $1;
} code {
    SF := 0;
    PF dead;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    AF dead;
}

pattern {
    asm or $1, $2;
} code {
    $1 := $1 | $2;
    long $n = $1;
    SF := $n < 0;
    PF dead;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    AF dead;
}

// INSN out($dest, $src);
// INSN outsb();
// INSN outsw();
// INSN outsd();
// INSN rep outsb();
// INSN rep outsw();
// INSN rep outsd();
// INSN pause();
// INSN pop($a);
// INSN popa();
// INSN popad();

INSN popcnt($dest, $src)
    ULONG $count := 0;
    if (sizeof($dest) == 2) {
        ULONG i := 0;
        while (i < 16) {
            if ($src & (1 << i)) {
                $count += 1;
            }
            i += 1;
        }
    } else if (sizeof($dest) == 4) {
        ULONG i := 0;
        while (i < 32) {
            if ($src & (1 << i)) {
                $count += 1;
            }
            i += 1;
        }
    }
    $dest := $count;
END INSN

// INSN popf();
// INSN popfd();
// INSN prefetch0($m8);
// INSN prefetch1($m8);
// INSN prefetch2($m8);
// INSN prefetchnta($m8);
// INSN push($a);
// INSN pusha();
// INSN pushad();
// INSN pushf();
// INSN pushfd();
// INSN rcl(XSIGNED $dest, XSIGNED $src);
// INSN rcr(XSIGNED $dest, XSIGNED $src);

pattern {
    asm rol $1, $2;
} code {
    $1 = _rotl($1, $2);
}

pattern {
    asm ror $1, $2;
} code {
    $1 = _rotr($1, $2);
}

// INSN rdmsr();
// INSN rdpmc();
// INSN rdrand($dest);
// INSN rdtsc();
// INSN rdtscp();
// INSN ret();
// INSN ret($imm16);
// INSN rsm();
// INSN sahf();

INSN sal(SIGNED $dest, XSIGNED $src)
    $dest <<= $src;
    CF dead;
    OF dead;
    ZF := $dest == 0;
    SF := $dest < 0;
    PF dead;
    AF dead;
    SFeqOF dead;
END INSN

INSN sar(SIGNED $dest, XSIGNED $src)
    $dest >>= $src;
    CF dead;
    OF dead;
    ZF := $dest == 0;
    SF := $dest < 0;
    PF dead;
    AF dead;
    SFeqOF dead;
END INSN

INSN shl(UNSIGNED $dest, XSIGNED $src)
    $dest <<= $src;
    CF dead;
    OF dead;
    ZF := $dest == 0;
    SF := $dest < 0;
    PF dead;
    AF dead;
    SFeqOF dead;
END INSN

INSN shr(UNSIGNED $dest, XSIGNED $src)
    $dest >>= $src;
    CF dead;
    OF dead;
    ZF := $dest == 0;
    SF := $dest < 0;
    PF dead;
    AF dead;
    SFeqOF dead;
END INSN

INSN sbb($dest, $src)
    SIGNED typeof($dest) $n1 := SIGNED($dest);
    SIGNED typeof($dest) $n2 := SIGNED($src) + CF;
    SFeqOF := $n1 >= $n2 + CF;
    UNSIGNED typeof($dest) $m1 := UNSIGNED($dest);
    UNSIGNED typeof($dest) $m2 := UNSIGNED($src) + CF;
    $dest -= $src + CF;
    SIGNED typeof($dest) $n3 := SIGNED($dest);
    UNSIGNED typeof($dest) $m3 := UNSIGNED($dest);
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $dest == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3 + CF || $m1 > $m3;
    AF dead;
    PF dead;
END INSN

INSN scasb()
    register XCHAR *edi := edi;
    BOOL $minus := al < 0;
    OF := $minus && *edi > 0;
    XCHAR $v := al - *edi;

    ZF := $v == 0;
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;

    if (DF) {
        edi -= 1;
    } else {
        edi += 1;
    }
END INSN

INSN scasw()
    register XSHORT *edi := edi;
    BOOL $minus := ax < 0;
    OF := $minus && *edi > 0;
    XSHORT $v := ax - *edi;

    ZF := $v == 0;
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;

    if (DF) {
        edi -= 1;
    } else {
        edi += 1;
    }
END INSN

INSN scasd()
    register XLONG *edi := edi;
    BOOL $minus := eax < 0;
    OF := $minus && *edi > 0;
    XLONG $v := eax - *edi;

    ZF := $v == 0;
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;

    if (DF) {
        edi -= 1;
    } else {
        edi += 1;
    }
END INSN

INSN repe scasb()
    register XCHAR *edi := edi;
    XCHAR $v;
    register ULONG ecx := ecx;
    BOOL $minus;
    if (DF) {
        while (ecx) {
            $minus := al < 0;
            OF := $minus && *edi > 0;
            $v := al - *edi;
            ZF := $v == 0;
            edi -= 1;
            ecx -= 1;
            if (!ZF) {
                break;
            }
        }
    } else {
        while (ecx) {
            $minus := al < 0;
            OF := $minus && *edi > 0;
            $v := al - *edi;
            ZF := $v == 0;
            edi += 1;
            ecx -= 1;
            if (!ZF) {
                break;
            }
        }
    }
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;
END INSN

INSN repe scasw()
    register XSHORT *edi := edi;
    XSHORT $v;
    register ULONG ecx := ecx;
    BOOL $minus;
    if (DF) {
        while (ecx) {
            $minus := ax < 0;
            OF := $minus && *edi > 0;
            $v := ax - *edi;
            ZF := $v == 0;
            edi -= 1;
            ecx -= 1;
            if (!ZF) {
                break;
            }
        }
    } else {
        while (ecx) {
            $minus := ax < 0;
            OF := $minus && *edi > 0;
            $v := ax - *edi;
            ZF := $v == 0;
            edi += 1;
            ecx -= 1;
            if (!ZF) {
                break;
            }
        }
    }
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;
END INSN

INSN repe scasd()
    register XLONG *edi := edi;
    XLONG $v;
    register ULONG ecx := ecx;
    BOOL $minus;
    if (DF) {
        while (ecx) {
            $minus := eax < 0;
            OF := $minus && *edi > 0;
            $v := eax - *edi;
            ZF := $v == 0;
            edi -= 1;
            ecx -= 1;
            if (!ZF) {
                break;
            }
        }
    } else {
        while (ecx) {
            $minus := eax < 0;
            OF := $minus && *edi > 0;
            $v := eax - *edi;
            ZF := $v == 0;
            edi += 1;
            ecx -= 1;
            if (!ZF) {
                break;
            }
        }
    }
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;
END INSN

alias repz scasb := repe scasb;
alias repz scasw := repe scasw;
alias repz scasd := repe scasd;

INSN repne scasb()
    register XCHAR *edi := edi;
    XCHAR $v;
    register ULONG ecx := ecx;
    BOOL $minus;
    if (DF) {
        while (ecx) {
            $minus := al < 0;
            OF := $minus && *edi > 0;
            $v := al - *edi;
            ZF := $v == 0;
            edi -= 1;
            ecx -= 1;
            if (ZF) {
                break;
            }
        }
    } else {
        while (ecx) {
            $minus := al < 0;
            OF := $minus && *edi > 0;
            $v := al - *edi;
            ZF := $v == 0;
            edi += 1;
            ecx -= 1;
            if (ZF) {
                break;
            }
        }
    }
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;
END INSN

INSN repne scasw()
    register XSHORT *edi := edi;
    XSHORT $v;
    register ULONG ecx := ecx;
    BOOL $minus;
    if (DF) {
        while (ecx) {
            $minus := ax < 0;
            OF := $minus && *edi > 0;
            $v := ax - *edi;
            ZF := $v == 0;
            edi -= 1;
            ecx -= 1;
            if (ZF) {
                break;
            }
        }
    } else {
        while (ecx) {
            $minus := ax < 0;
            OF := $minus && *edi > 0;
            $v := ax - *edi;
            ZF := $v == 0;
            edi += 1;
            ecx -= 1;
            if (ZF) {
                break;
            }
        }
    }
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;
END INSN

INSN repne scasd()
    register XLONG *edi := edi;
    XLONG $v;
    register ULONG ecx := ecx;
    BOOL $minus;
    if (DF) {
        while (ecx) {
            $minus := eax < 0;
            OF := $minus && *edi > 0;
            $v := eax - *edi;
            ZF := $v == 0;
            edi -= 1;
            ecx -= 1;
            if (ZF) {
                break;
            }
        }
    } else {
        while (ecx) {
            $minus := eax < 0;
            OF := $minus && *edi > 0;
            $v := eax - *edi;
            ZF := $v == 0;
            edi += 1;
            ecx -= 1;
            if (ZF) {
                break;
            }
        }
    }
    SF := $v < 0;
    AF dead;
    PF dead;
    CF dead;
    SFeqOF := $v >= 0;
END INSN

alias repnz scasb := repne scasb;
alias repnz scasw := repne scasw;
alias repnz scasd := repne scasd;

pattern {
    asm seta $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF && !CF;
}

pattern {
    asm setae $1;
} code {
    assume $1 as xsigned char;
    $1 := !CF;
}

pattern {
    asm setb $1;
} code {
    assume $1 as xsigned char;
    $1 := CF;
}

pattern {
    asm setbe $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF || CF;
}

pattern {
    asm setc $1;
} code {
    assume $1 as xsigned char;
    $1 := CF;
}

pattern {
    asm sete $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF;
}

pattern {
    asm setg $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF && SF == OF;
}

pattern {
    asm setge $1;
} code {
    assume $1 as xsigned char;
    $1 := SF == OF;
}

pattern {
    asm setl $1;
} code {
    assume $1 as xsigned char;
    $1 := SF != OF;
}

pattern {
    asm setle $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF && SF != OF;
}

pattern {
    asm setna $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF || CF;
}

pattern {
    asm setnae $1;
} code {
    assume $1 as xsigned char;
    $1 := CF;
}

pattern {
    asm setnb $1;
} code {
    assume $1 as xsigned char;
    $1 := !CF;
}

pattern {
    asm setnbe $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF && !CF;
}

pattern {
    asm setnc $1;
} code {
    assume $1 as xsigned char;
    $1 := !CF;
}

pattern {
    asm setne $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF;
}

pattern {
    asm setng $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF || SF != OF;
}

pattern {
    asm setnge $1;
} code {
    assume $1 as xsigned char;
    $1 := SF != OF;
}

pattern {
    asm setnl $1;
} code {
    assume $1 as xsigned char;
    $1 := SF == OF;
}

pattern {
    asm setnle $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF && SF == OF;
}

pattern {
    asm setno $1;
} code {
    assume $1 as xsigned char;
    $1 := !OF;
}

pattern {
    asm setnp $1;
} code {
    assume $1 as xsigned char;
    $1 := !PF;
}

pattern {
    asm setns $1;
} code {
    assume $1 as xsigned char;
    $1 := !SF;
}

pattern {
    asm setnz $1;
} code {
    assume $1 as xsigned char;
    $1 := !ZF;
}

pattern {
    asm seto $1;
} code {
    assume $1 as xsigned char;
    $1 := OF;
}

pattern {
    asm setp $1;
} code {
    assume $1 as xsigned char;
    $1 := PF;
}

pattern {
    asm setpe $1;
} code {
    assume $1 as xsigned char;
    $1 := PF;
}

pattern {
    asm setpo $1;
} code {
    assume $1 as xsigned char;
    $1 := !PF;
}


pattern {
    asm sets $1;
} code {
    assume $1 as xsigned char;
    $1 := !SF;
}

pattern {
    asm setz $1;
} code {
    assume $1 as xsigned char;
    $1 := ZF;
}

// INSN sfence();
// INSN sgdt();
// INSN shld($dest, $src, $count);   // TODO:
// INSN shrd($dest, $src, $count);   // TODO:
// INSN sidt($m);
// INSN sldt($rm16);
// INSN smsw($rm);

pattern {
    asm stc;
} code {
    CF := 1;
}

pattern {
    asm std;
} code {
    DF := 1;
}

// INSN sti()

pattern {
    assume !DF;
    asm stosb;
} code {
    assume edi as xsigned char *;
    assume al as xsigned char;
    *edi := al;
    edi := edi + 1;
}

pattern {
    assume DF;
    asm stosb;
} code {
    assume edi as xsigned char *;
    assume al as xsigned char;
    *edi := al;
    edi := edi - 1;
}

pattern {
    assume !DF;
    asm stosw;
} code {
    assume edi as xsigned short *;
    assume ax as xsigned short;
    *edi := ax;
    edi := edi + 1;
}

pattern {
    assume DF;
    asm stosw;
} code {
    assume edi as xsigned short *;
    assume ax as xsigned short;
    *edi := ax;
    edi := edi - 1;
}

pattern {
    assume !DF;
    asm stosd;
} code {
    assume edi as xsigned long *;
    assume eax as xsigned long;
    *edi := eax;
    edi := edi + 1;
}

pattern {
    assume DF;
    asm stosd;
} code {
    assume edi as xsigned long *;
    assume eax as xsigned long;
    *edi := eax;
    edi := edi - 1;
}

pattern {
    assume !DF;
    asm rep stosb;
} code {
    assume edi as xsigned char *;
    assume al as xsigned char;
    assume ecx as integer;
    memset(edi, al, ecx);
    edi := edi + ecx;
    ecx := 0;
}

pattern {
    assume DF;
    asm rep stosb;
} code {
    assume edi as xsigned char *;
    assume al as xsigned char;
    assume ecx as integer;
    memset(edi - ecx, al, ecx);
    edi := edi - ecx;
    ecx := 0;
}

pattern {
    assume !DF;
    asm rep stosw;
} code {
    assume edi as xsigned short *;
    assume ax as xsigned short;
$loop:
    if (!ecx) goto $skip;
    *edi := ax;
    edi := edi + 1;
    ecx := ecx - 1;
    goto $loop;
$skip:
}

pattern {
    assume DF;
    asm rep stosw;
} code {
    assume edi as xsigned short *;
    assume ax as xsigned short;
$loop:
    if (!ecx) goto $skip;
    *edi := ax;
    edi := edi - 1;
    ecx := ecx - 1;
    goto $loop;
$skip:
}

pattern {
    assume !DF;
    asm rep stosd;
} code {
    assume edi as xsigned long *;
    assume eax as xsigned long;
$loop:
    if (!ecx) goto $skip;
    *edi := eax;
    edi := edi + 1;
    ecx := ecx - 1;
    goto $loop;
$skip:
}

pattern {
    assume DF;
    asm rep stosd;
} code {
    assume edi as xsigned long *;
    assume eax as xsigned long;
$loop:
    if (!ecx) goto $skip;
    *edi := eax;
    edi := edi - 1;
    ecx := ecx - 1;
    goto $loop;
$skip:
}

// INSN str($rm16);

pattern {
    asm sub $1, $2;
    assume sizeof($1) == 4;
} code {
	long $n1;
	long $n2;
	long $n3;
	unsigned long $m1;
	unsigned long $m2;
	unsigned long $m3;
    $n1 := $1;
    $n2 := $2;
    $m1 := $1;
    $m2 := $2;
    $1 := $1 - $2;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $dest == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    AF dead;
    PF dead;
    updated $1;
}

pattern {
    asm sub $1, $2;
    assume sizeof($1) == 2;
} code {
	short $n1;
	short $n2;
	short $n3;
	unsigned short $m1;
	unsigned short $m2;
	unsigned short $m3;
    $n1 := $1;
    $n2 := $2;
    $m1 := $1;
    $m2 := $2;
    $1 := $1 - $2;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $dest == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    AF dead;
    PF dead;
    updated $1;
}

pattern {
    asm sub $1, $2;
    assume sizeof($1) == 4;
} code {
	char $n1;
	char $n2;
	char $n3;
	unsigned char $m1;
	unsigned char $m2;
	unsigned char $m3;
    $n1 := $1;
    $n2 := $2;
    $m1 := $1;
    $m2 := $2;
    $1 := $1 - $2;
    $n3 := $1;
    $m3 := $1;
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $dest == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    AF dead;
    PF dead;
    updated $1;
}

// INSN sysenter();
// INSN sysexit();

pattern {
    asm test $1, $1;
    assume sizeof($1) == 4;
} code {
    ZF := $1 == 0;
    long $temp := $1;
    SF := $temp < 0;
    PF dead;
    CF := 0;
    OF := 0;
    AF dead;
}

pattern {
    asm test $1, $1;
    assume sizeof($1) == 2;
} code {
    ZF := $1 == 0;
    short $temp := $1;
    SF := $temp < 0;
    PF dead;
    CF := 0;
    OF := 0;
    AF dead;
}

pattern {
    asm test $1, $1;
    assume sizeof($1) == 1;
} code {
    ZF := $1 == 0;
    char $temp := $1;
    SF := $temp < 0;
    PF dead;
    CF := 0;
    OF := 0;
    AF dead;
}

pattern {
    asm test $1, $2;
    assume sizeof($1) == 4;
} code {
    long $temp := ($1 & $2);
    ZF := $temp == 0;
    SF := $temp < 0;
    PF dead;
    CF := 0;
    OF := 0;
    AF dead;
}

pattern {
    asm test $1, $2;
    assume sizeof($1) == 2;
} code {
    short $temp := ($1 & $2);
    ZF := $temp == 0;
    SF := $temp < 0;
    PF dead;
    CF := 0;
    OF := 0;
    AF dead;
}

pattern {
    asm test $1, $2;
    assume sizeof($1) == 1;
} code {
    char $temp := ($1 & $2);
    ZF := $temp == 0;
    SF := $temp < 0;
    PF dead;
    CF := 0;
    OF := 0;
    AF dead;
}

// INSN ud2();
// INSN verr($rm16);
// INSN verw($rm16);
// INSN wait();
// INSN fwait();
// INSN wbinvd();
// INSN wrmsr();

INSN xadd(XSIGNED $dest, XSIGNED $src)
    SIGNED typeof($dest) $n1 := SIGNED($dest);
    SIGNED typeof($dest) $n2 := SIGNED($src);
    SFeqOF := $n1 >= -$n2;
    UNSIGNED typeof($dest) $m1 := UNSIGNED($dest);
    UNSIGNED typeof($dest) $m2 := UNSIGNED($src);
    typeof($dest) $temp := $dest + $src;
    $src := $dest;
    $dest := $temp;
    SIGNED typeof($dest) $n3 := SIGNED($dest);
    UNSIGNED typeof($dest) $m3 := UNSIGNED($dest);
    OF := ($n1 >= 0 && $n2 >= 0 && $n3 < 0) || ($n1 < 0 && $n2 < 0 && $n3 >= 0);
    ZF := $dest == 0;
    SF := $n3 < 0;
    CF := $m1 > $m3;
    AF dead;
    PF dead;
END INSN

pattern {
    asm xchg $1, $2;
    assume sizeof($1) == 4;
} code {
    xsigned long $x := $1;
    $1 := $2;
    $2 := $x;
}

pattern {
    asm xchg $1, $2;
    assume sizeof($1) == 2;
} code {
    xsigned short $x := $1;
    $1 := $2;
    $2 := $x;
}

pattern {
    asm xchg $1, $2;
    assume sizeof($1) == 1;
} code {
    xsigned char $x := $1;
    $1 := $2;
    $2 := $x;
}

// INSN xgetbv();

pattern {
    asm xlat $1;
} code {
    assume $1 as xsigned char *;
    al := $1[al];
    updated al;
}

pattern {
    asm xlatb $1;
} code {
    assume $1 as xsigned char *;
    al := $1[al];
    updated al;
}

pattern {
    asm xor $1,$1;
} code {
    $1 := 0;
    assume $1 as integer;
    SF := 0;
    ZF := 1;
    OF := 0;
    CF := 0;
    PF dead;
    AF dead;
}

pattern {
    asm xor $1,$2;
} code {
    $1 := $1 ^ $2;
    assume $1 as integer;
    SF := $1 < 0;
    ZF := $1 == 0;
    OF := 0;
    CF := 0;
    PF dead;
    AF dead;
}

// INSN xrstor($mem);
// INSN xsave($mem);
// INSN xsaveopt($mem);
// INSN xsetbv();
